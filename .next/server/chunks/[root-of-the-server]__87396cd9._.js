module.exports = [
"[project]/Downloads/mrpii 2/.next-internal/server/app/api/analytics/historical/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/dns [external] (dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns", () => require("dns"));

module.exports = mod;
}),
"[externals]/constants [external] (constants, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("constants", () => require("constants"));

module.exports = mod;
}),
"[externals]/node:os [external] (node:os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:os", () => require("node:os"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/node:process [external] (node:process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:http [external] (node:http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http", () => require("node:http"));

module.exports = mod;
}),
"[externals]/node:https [external] (node:https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:https", () => require("node:https"));

module.exports = mod;
}),
"[externals]/node:zlib [external] (node:zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:zlib", () => require("node:zlib"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/node:fs/promises [external] (node:fs/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs/promises", () => require("node:fs/promises"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[externals]/node:child_process [external] (node:child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:child_process", () => require("node:child_process"));

module.exports = mod;
}),
"[externals]/dgram [external] (dgram, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dgram", () => require("dgram"));

module.exports = mod;
}),
"[externals]/node:url [external] (node:url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:url", () => require("node:url"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[project]/Downloads/mrpii 2/lib/database/connection.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "closeDbConnection",
    ()=>closeDbConnection,
    "executeQuery",
    ()=>executeQuery,
    "getDbConnection",
    ()=>getDbConnection,
    "testConnections",
    ()=>testConnections
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/node_modules/tedious/lib/tedious.js [app-route] (ecmascript)");
;
// Configuraciones para múltiples bases de datos como en el PHP original
const baseConfig = {
    server: process.env.DB_SERVER || '10.0.0.45',
    authentication: {
        type: 'default',
        options: {
            userName: process.env.DB_USER || 'sa',
            password: process.env.DB_PASSWORD || 'Mapexdd2017'
        }
    },
    options: {
        port: parseInt(process.env.DB_PORT || '1433'),
        encrypt: false,
        trustServerCertificate: true,
        connectTimeout: 30000,
        requestTimeout: 30000,
        enableArithAbort: true
    }
};
// Configuraciones específicas para cada base de datos
const mapexConfig = {
    ...baseConfig,
    options: {
        ...baseConfig.options,
        database: process.env.DB_NAME || 'mapexbp_Test'
    }
};
const sageConfig = {
    ...baseConfig,
    authentication: {
        type: 'default',
        options: {
            userName: 'sa',
            password: 'admin000'
        }
    },
    options: {
        ...baseConfig.options,
        database: 'SAGE'
    }
};
const whalesConfig = {
    ...baseConfig,
    authentication: {
        type: 'default',
        options: {
            userName: 'sa',
            password: '87cc88bb89.'
        }
    },
    options: {
        ...baseConfig.options,
        database: 'WHALES'
    }
};
async function getDbConnection(database = 'mapex') {
    let config;
    switch(database){
        case 'mapex':
            config = mapexConfig;
            break;
        case 'sage':
            config = sageConfig;
            break;
        case 'whales':
            config = whalesConfig;
            break;
        default:
            config = mapexConfig;
    }
    const connection = new __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Connection"](config);
    return new Promise((resolve, reject)=>{
        connection.on('connect', (err)=>{
            if (err) {
                console.error(`❌ Erro ao conectar à base ${database.toUpperCase()}:`, err);
                reject(err);
            } else {
                console.log(`✅ Nova conexão criada para ${database.toUpperCase()}`);
                resolve(connection);
            }
        });
        connection.on('error', (err)=>{
            console.error(`❌ Erro na conexão ${database.toUpperCase()}:`, err);
            reject(err);
        });
        // Não definir on('end') aqui pois vamos fechar manualmente
        connection.connect();
    });
}
async function executeQuery(sql, parameters, database = 'mapex') {
    const conn = await getDbConnection(database);
    return new Promise((resolve, reject)=>{
        const results = [];
        const request = new __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Request"](sql, (err)=>{
            // Sempre fechar a conexão após completar a query
            try {
                conn.close();
            } catch (closeErr) {
                console.warn('⚠️ Erro ao fechar conexão:', closeErr);
            }
            if (err) {
                console.error(`❌ Erro na query ${database.toUpperCase()}:`, err);
                console.error('SQL:', sql.substring(0, 200) + '...');
                reject(err);
            } else {
                resolve(results);
            }
        });
        // Adicionar parâmetros se fornecidos
        if (parameters) {
            Object.entries(parameters).forEach(([key, value])=>{
                let type = __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TYPES"].NVarChar;
                if (typeof value === 'number') {
                    type = Number.isInteger(value) ? __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TYPES"].Int : __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TYPES"].Float;
                } else if (typeof value === 'boolean') {
                    type = __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TYPES"].Bit;
                } else if (value instanceof Date) {
                    type = __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TYPES"].DateTime;
                }
                request.addParameter(key, type, value);
            });
        }
        request.on('row', (columns)=>{
            const row = {};
            columns.forEach((column)=>{
                row[column.metadata.colName] = column.value;
            });
            results.push(row);
        });
        try {
            conn.execSql(request);
        } catch (execErr) {
            // Se houver erro na execução, fechar conexão e rejeitar
            try {
                conn.close();
            } catch (closeErr) {
                console.warn('⚠️ Erro ao fechar conexão após falha:', closeErr);
            }
            reject(execErr);
        }
    });
}
async function closeDbConnection(database) {
    // Como agora criamos uma nova conexão para cada query e fechamos automaticamente,
    // esta função é mantida por compatibilidade mas não faz mais sentido
    console.log('ℹ️ Conexões agora são gerenciadas automaticamente por query');
}
async function testConnections() {
    const results = {};
    for (const db of [
        'mapex',
        'sage',
        'whales'
    ]){
        try {
            await executeQuery('SELECT 1 as test', undefined, db);
            results[db] = true;
            console.log(`✅ Teste de conectividade ${db.toUpperCase()}: OK`);
        } catch (error) {
            results[db] = false;
            console.error(`❌ Teste de conectividade ${db.toUpperCase()}: FALHOU`, error);
        }
    }
    return results;
}
}),
"[project]/Downloads/mrpii 2/src/app/api/scada/costs-config/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET,
    "POST",
    ()=>POST,
    "getAllProductCosts",
    ()=>getAllProductCosts,
    "getProductCost",
    ()=>getProductCost
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/lib/database/connection.ts [app-route] (ecmascript)");
;
;
async function getProductCost(cod_producto) {
    try {
        // Consulta simple para obtener costo configurado
        const sql = `
      SELECT TOP 1
        cp.cod_producto,
        0 as costo_default -- Por defecto
      FROM cfg_producto cp
      WHERE cp.cod_producto = @cod_producto
        AND cp.activo = 1
    `;
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql, {
            cod_producto
        });
        if (!result || result.length === 0) {
            console.warn(`⚠️ Producto ${cod_producto} no encontrado, usando costo por defecto €0`);
            return 0;
        }
        // Por ahora, retornar costo por defecto
        // TODO: Implementar tabla de configuración real
        return 0;
    } catch (error) {
        console.error(`❌ Error obteniendo costo para ${cod_producto}:`, error);
        return 0; // Fallback a valor por defecto
    }
}
async function getAllProductCosts() {
    try {
        console.log('💰 Obteniendo todos los costos de productos');
        // Consulta para obtener todos los productos activos
        const sql = `
      SELECT DISTINCT
        cp.cod_producto,
        0 as costo_default -- Por defecto
      FROM cfg_producto cp
      WHERE cp.activo = 1
        AND cp.cod_producto IS NOT NULL
        AND cp.cod_producto != ''
        AND cp.cod_producto != '--'
        AND cp.cod_producto != '{0}'
    `;
        const products = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
        const costMap = {};
        if (products && products.length > 0) {
            products.forEach((product)=>{
                costMap[product.cod_producto] = product.costo_default;
            });
        }
        console.log(`💰 Costos obtenidos para ${Object.keys(costMap).length} productos`);
        return costMap;
    } catch (error) {
        console.error('❌ Error obteniendo todos los costos:', error);
        return {}; // Retornar mapa vacío como fallback
    }
}
async function GET(request) {
    try {
        console.log('⚙️ Obteniendo configuración de costos');
        // Obtener productos con sus máquinas asociadas
        const sql = `
      SELECT DISTINCT
        cp.cod_producto,
        cp.desc_producto,
        cm.Cod_maquina,
        cm.desc_maquina,
        0 as costo_unitario_default -- Sin productos = costo cero
      FROM cfg_producto cp
      LEFT JOIN cfg_maquina cm ON cp.cod_producto = cm.rt_Cod_producto
      WHERE cp.activo = 1
        AND cp.cod_producto IS NOT NULL
        AND cp.cod_producto != ''
        AND cp.cod_producto != '--'
        AND cp.cod_producto != '{0}'
      ORDER BY cp.cod_producto, cm.Cod_maquina
    `;
        const products = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
        // Crear estructura de respuesta
        const costConfig = {};
        products.forEach((product)=>{
            const productKey = product.cod_producto;
            if (!costConfig[productKey]) {
                costConfig[productKey] = {
                    cod_producto: product.cod_producto,
                    desc_producto: product.desc_producto,
                    costo_unitario: product.costo_unitario_default,
                    maquinas: [],
                    nota: 'Costo configurado manualmente (no viene de MAPEX)'
                };
            }
            if (product.Cod_maquina) {
                costConfig[productKey].maquinas.push({
                    cod_maquina: product.Cod_maquina,
                    desc_maquina: product.desc_maquina
                });
            }
        });
        console.log('⚙️ Configuración de costos obtenida:', Object.keys(costConfig).length, 'productos');
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            data: costConfig,
            timestamp: new Date().toISOString(),
            nota: 'Costos por defecto: €0. Configure valores reales usando POST'
        });
    } catch (error) {
        console.error('❌ Error obteniendo configuración de costos:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Error al obtener configuración de costos',
            details: error instanceof Error ? error.message : 'Error desconocido',
            timestamp: new Date().toISOString()
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    try {
        console.log('💾 Configurando costo personalizado');
        const body = await request.json();
        const { cod_producto, costo_unitario, maquina_id } = body;
        if (!cod_producto || costo_unitario === undefined) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Faltan parámetros requeridos: cod_producto y costo_unitario',
                timestamp: new Date().toISOString()
            }, {
                status: 400
            });
        }
        // Validar que el producto existe en MAPEX
        const checkProductSql = `
      SELECT cod_producto, desc_producto
      FROM cfg_producto
      WHERE cod_producto = @cod_producto
        AND activo = 1
    `;
        const productExists = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(checkProductSql, {
            cod_producto
        });
        if (!productExists || productExists.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: `Producto ${cod_producto} no encontrado en MAPEX`,
                timestamp: new Date().toISOString()
            }, {
                status: 404
            });
        }
        // Aquí se podría guardar en una tabla de configuración
        // Por ahora, simularemos el guardado
        console.log('💾 Costo configurado:', {
            cod_producto,
            costo_unitario,
            maquina_id,
            producto: productExists[0].desc_producto
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: `Costo de €${costo_unitario} configurado para producto ${cod_producto}`,
            data: {
                cod_producto,
                costo_unitario: parseFloat(costo_unitario),
                maquina_id,
                producto_descripcion: productExists[0].desc_producto
            },
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('❌ Error configurando costo:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Error al configurar costo',
            details: error instanceof Error ? error.message : 'Error desconocido',
            timestamp: new Date().toISOString()
        }, {
            status: 500
        });
    }
}
}),
"[project]/Downloads/mrpii 2/src/app/api/analytics/historical/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/lib/database/connection.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$src$2f$app$2f$api$2f$scada$2f$costs$2d$config$2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/src/app/api/scada/costs-config/route.ts [app-route] (ecmascript)");
;
;
;
async function GET(request) {
    try {
        const searchParams = request.nextUrl.searchParams;
        const machineId = searchParams.get('machineId') || null;
        const days = parseInt(searchParams.get('days') || '30');
        console.log(`📊 Buscando datos históricos - Máquina: ${machineId}, Días: ${days}`);
        // Obtener costos de productos desde MAPEX
        const productCosts = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$src$2f$app$2f$api$2f$scada$2f$costs$2d$config$2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAllProductCosts"])();
        const costoPromedioNok = Object.keys(productCosts).length > 0 ? Object.values(productCosts).reduce((sum, cost)=>sum + cost, 0) / Object.keys(productCosts).length : 15.50; // Fallback al valor por defecto
        console.log('💰 Costo promedio para cálculos históricos:', {
            totalProductos: Object.keys(productCosts).length,
            costoPromedio: costoPromedioNok,
            nota: 'Usado para calcular costos de scrap en consultas SQL'
        });
        // Intentar obtener datos reales de MAPEX
        let productionData = [];
        let downtimeData = [];
        try {
            // Query muy simple para testear conectividad
            const testSql = `SELECT TOP 1 'OK' as status, GETDATE() as fecha`;
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(testSql, undefined, 'mapex');
            console.log('✅ Conexión MAPEX OK');
            // Query simplificada para producción
            const productionSql = `
        SELECT TOP 10
          CONVERT(VARCHAR(10), hp.fecha, 120) as fecha,
          cm.Cod_maquina,
          COUNT(*) as registros
        FROM his_prod hp
        INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina
        WHERE hp.fecha >= DATEADD(day, -${days}, GETDATE())
          AND cm.activo = 1
          ${machineId ? `AND cm.Cod_maquina = '${machineId}'` : ''}
        GROUP BY CONVERT(VARCHAR(10), hp.fecha, 120), cm.Cod_maquina
        ORDER BY fecha DESC
      `;
            productionData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(productionSql, undefined, 'mapex');
            console.log(`📊 Datos de producción: ${productionData.length} registros`);
        } catch (prodError) {
            const prodMsg = prodError instanceof Error ? prodError.message : String(prodError);
            console.warn('⚠️ Error al buscar datos de producción:', prodMsg);
            console.warn('⚠️ Usando datos simulados para producción');
            productionData = getSimulatedProductionData(days, machineId);
        }
        try {
            // Query simplificada para paros
            const downtimeSql = `
        SELECT TOP 10
          CONVERT(VARCHAR(10), hpp.fecha_inicio, 120) as fecha,
          cm.Cod_maquina,
          COUNT(*) as num_paros
        FROM his_prod_paro hpp
        INNER JOIN his_prod hp ON hpp.id_his_prod = hp.id_his_prod
        INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina
        WHERE hpp.fecha_inicio >= DATEADD(day, -${days}, GETDATE())
          AND cm.activo = 1
          ${machineId ? `AND cm.Cod_maquina = '${machineId}'` : ''}
        GROUP BY CONVERT(VARCHAR(10), hpp.fecha_inicio, 120), cm.Cod_maquina
        ORDER BY fecha DESC
      `;
            downtimeData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(downtimeSql, undefined, 'mapex');
            console.log(`📊 Datos de paros: ${downtimeData.length} registros`);
        } catch (downError) {
            const downMsg = downError instanceof Error ? downError.message : String(downError);
            console.warn('⚠️ Error al buscar datos de paros:', downMsg);
            console.warn('⚠️ Usando datos simulados para paros');
            downtimeData = getSimulatedDowntimeData(days, machineId);
        }
        // Insights básicos
        const insights = [];
        if (productionData.length > 0) {
            const totalRegistros = productionData.reduce((sum, item)=>sum + (item.registros || 0), 0);
            insights.push({
                tipo: 'PRODUCCION_RESUMEN',
                mensaje: `Total registros de producción: ${totalRegistros} en ${productionData.length} días`,
                prioridad: 'INFO'
            });
        }
        if (downtimeData.length > 0) {
            const totalParos = downtimeData.reduce((sum, item)=>sum + (item.num_paros || 0), 0);
            insights.push({
                tipo: 'PAROS_RESUMEN',
                mensaje: `Total paros registrados: ${totalParos} en ${downtimeData.length} días`,
                prioridad: 'INFO'
            });
        }
        // Obtener datos adicionales necesarios para los gráficos
        let oeeHistory = [];
        let costAnalysis = [];
        let operatorMetrics = [];
        try {
            // Intentar obtener datos de OEE histórico
            oeeHistory = await calculateHistoricalOEE(machineId, days, 'day');
            console.log(`📊 Datos OEE histórico: ${oeeHistory.length} registros`);
        } catch (oeeError) {
            console.warn('⚠️ Error al obtener OEE histórico:', oeeError);
            oeeHistory = [];
        }
        try {
            // Intentar obtener análisis de costos
            costAnalysis = await getCostAnalysis(machineId, days);
            console.log(`💰 Análisis de costos: ${costAnalysis.length} registros`);
        } catch (costError) {
            console.warn('⚠️ Error al obtener análisis de costos:', costError);
            costAnalysis = [];
        }
        try {
            // Intentar obtener métricas de operadores
            operatorMetrics = await getOperatorProductivityMetrics(machineId, days);
            console.log(`👥 Métricas de operadores: ${operatorMetrics.length} registros`);
        } catch (opError) {
            console.warn('⚠️ Error al obtener métricas de operadores:', opError);
            operatorMetrics = [];
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            data: {
                production: productionData,
                downtime: downtimeData,
                oee_history: oeeHistory,
                cost_analysis: costAnalysis,
                operator_metrics: operatorMetrics,
                insights: insights,
                summary: {
                    avg_oee: oeeHistory.length > 0 ? oeeHistory.reduce((sum, item)=>sum + (item.oee || 0), 0) / oeeHistory.length : 0,
                    total_production: productionData.reduce((sum, item)=>sum + (item.registros || 0), 0),
                    total_downtime_hours: downtimeData.reduce((sum, item)=>sum + (item.num_paros || 0), 0) * 0.5,
                    total_records: productionData.length + downtimeData.length
                },
                filters: {
                    machineId,
                    days,
                    dateRange: {
                        from: new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                        to: new Date().toISOString().split('T')[0]
                    }
                }
            },
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('❌ Error en datos históricos:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Error al obtener datos históricos',
            message: error instanceof Error ? error.message : 'Error desconocido'
        }, {
            status: 500
        });
    }
}
// Función para generar datos simulados de producción
function getSimulatedProductionData(days, machineId) {
    const data = [];
    const machines = [
        'DOBL01',
        'DOBL02',
        'SOLD01',
        'SOLD02',
        'TROQ01',
        'TERM01'
    ];
    const targetMachines = machineId ? [
        machineId
    ] : machines;
    for(let i = days; i >= 0; i--){
        const date = new Date();
        date.setDate(date.getDate() - i);
        targetMachines.forEach((machine)=>{
            data.push({
                fecha: date.toISOString().split('T')[0],
                Cod_maquina: machine,
                registros: Math.floor(Math.random() * 50) + 10 // 10-60 registros por día
            });
        });
    }
    return data;
}
// Función para generar datos simulados de paros
function getSimulatedDowntimeData(days, machineId) {
    const data = [];
    const machines = [
        'DOBL01',
        'DOBL02',
        'SOLD01',
        'SOLD02',
        'TROQ01',
        'TERM01'
    ];
    const targetMachines = machineId ? [
        machineId
    ] : machines;
    for(let i = days; i >= 0; i--){
        const date = new Date();
        date.setDate(date.getDate() - i);
        targetMachines.forEach((machine)=>{
            // Solo algunos días tienen paros
            if (Math.random() < 0.3) {
                data.push({
                    fecha: date.toISOString().split('T')[0],
                    Cod_maquina: machine,
                    num_paros: Math.floor(Math.random() * 3) + 1 // 1-3 paros por día
                });
            }
        });
    }
    return data;
}
async function getHistoricalProductionData(machineId, days, aggregation) {
    const machineFilter = machineId ? `AND cm.Cod_maquina = '${machineId}'` : '';
    let dateFormat = '';
    let groupBy = '';
    switch(aggregation){
        case 'minute':
            dateFormat = "FORMAT(hp.fecha, 'yyyy-MM-dd HH:mm')";
            groupBy = "FORMAT(hp.fecha, 'yyyy-MM-dd HH:mm'), cm.Cod_maquina";
            break;
        case 'hour':
            dateFormat = "FORMAT(hp.fecha, 'yyyy-MM-dd HH')";
            groupBy = "FORMAT(hp.fecha, 'yyyy-MM-dd HH'), cm.Cod_maquina";
            break;
        case 'day':
            dateFormat = "FORMAT(hp.fecha, 'yyyy-MM-dd')";
            groupBy = "FORMAT(hp.fecha, 'yyyy-MM-dd'), cm.Cod_maquina";
            break;
    }
    const sql = `
    SELECT
      ${dateFormat} as periodo,
      cm.Cod_maquina,
      cm.desc_maquina,
      SUM(hp.unidades_ok) as piezas_ok,
      SUM(hp.unidades_nok) as piezas_nok,
      SUM(hp.unidades_rw) as piezas_rw,
      SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_rw) as total_pieces,
      AVG(hp.velocidad_real) as velocidad_promedio,
      AVG(hp.tiempo_ciclo_real) as tiempo_ciclo_promedio,
      COUNT(*) as registros,
      STRING_AGG(hp.turno, ',') as turnos,
      STRING_AGG(DISTINCT hp.operario, ',') as operarios
    FROM his_prod hp
    INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina
    WHERE hp.fecha >= DATEADD(day, -${days}, GETDATE())
      AND cm.activo = 1
      ${machineFilter}
    GROUP BY ${groupBy}
    ORDER BY periodo DESC, cm.Cod_maquina
  `;
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
}
async function getHistoricalDowntimeData(machineId, days) {
    const machineFilter = machineId ? `AND cm.Cod_maquina = '${machineId}'` : '';
    const sql = `
    SELECT
      FORMAT(hpp.fecha_inicio, 'yyyy-MM-dd HH:mm') as fecha_inicio,
      FORMAT(hpp.fecha_fin, 'yyyy-MM-dd HH:mm') as fecha_fin,
      cm.Cod_maquina,
      cm.desc_maquina,
      hpp.duracion_minutos,
      CAST(hpp.duracion_minutos AS FLOAT) / 60 as duracion_horas,
      hpp.tipo_paro,
      hpp.desc_paro as causa,
      hpp.operario,
      CASE WHEN cpp.es_planificado = 1 THEN 1 ELSE 0 END as es_planificada,
      cpp.costo_hora_estimado,
      (CAST(hpp.duracion_minutos AS FLOAT) / 60) * ISNULL(cpp.costo_hora_estimado, 150) as costo_estimado_euros
    FROM his_prod_paro hpp
    INNER JOIN cfg_maquina cm ON hpp.id_maquina = cm.id_maquina
    LEFT JOIN cfg_paro cpp ON hpp.id_tipo_paro = cpp.id_paro
    WHERE hpp.fecha_inicio >= DATEADD(day, -${days}, GETDATE())
      AND cm.activo = 1
      ${machineFilter}
    ORDER BY hpp.fecha_inicio DESC
  `;
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
}
async function calculateHistoricalOEE(machineId, days, aggregation) {
    const machineFilter = machineId ? `AND cm.Cod_maquina = '${machineId}'` : '';
    let dateFormat = '';
    switch(aggregation){
        case 'hour':
            dateFormat = "FORMAT(fecha, 'yyyy-MM-dd HH')";
            break;
        case 'day':
            dateFormat = "FORMAT(fecha, 'yyyy-MM-dd')";
            break;
        default:
            dateFormat = "FORMAT(fecha, 'yyyy-MM-dd HH')";
    }
    const sql = `
    SELECT
      ${dateFormat} as periodo,
      cm.Cod_maquina,
      cm.desc_maquina,
      AVG(CAST(disponibilidad AS FLOAT)) as disponibilidad,
      AVG(CAST(rendimiento AS FLOAT)) as rendimiento,
      AVG(CAST(calidad AS FLOAT)) as calidad,
      AVG(CAST(oee AS FLOAT)) as oee,
      AVG(tiempo_planificado_min) as tiempo_planificado_promedio,
      SUM(piezas_producidas) as total_piezas,
      COUNT(*) as mediciones
    FROM his_horaOEE hoee
    INNER JOIN cfg_maquina cm ON hoee.id_maquina = cm.id_maquina
    WHERE hoee.fecha >= DATEADD(day, -${days}, GETDATE())
      AND cm.activo = 1
      ${machineFilter}
    GROUP BY ${dateFormat}, cm.Cod_maquina, cm.desc_maquina
    ORDER BY periodo DESC, cm.Cod_maquina
  `;
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
}
async function getOperatorProductivityMetrics(machineId, days) {
    const machineFilter = machineId ? `AND cm.Cod_maquina = '${machineId}'` : '';
    const sql = `
    SELECT
      hp.operario,
      cm.Cod_maquina,
      COUNT(DISTINCT CAST(hp.fecha AS DATE)) as dias_trabajados,
      SUM(hp.unidades_ok) as total_piezas_ok,
      SUM(hp.unidades_nok) as total_piezas_nok,
      SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_rw) as total_piezas,
      AVG(CAST(hp.unidades_ok AS FLOAT) / NULLIF(hp.unidades_ok + hp.unidades_nok + hp.unidades_rw, 0)) as eficiencia_promedio,
      SUM(hp.tiempo_trabajado_min) as total_minutos_trabajados,
      CASE
        WHEN SUM(hp.tiempo_trabajado_min) > 0
        THEN (SUM(hp.unidades_ok) * 60.0) / SUM(hp.tiempo_trabajado_min)
        ELSE 0
      END as piezas_por_hora,
      -- Calcular costo de ineficiencia
      SUM(hp.unidades_nok) * 15.5 as costo_scrap_euros, -- Costo promedio fallback (no disponible aquí)
      -- Ranking por productividad
      RANK() OVER (ORDER BY
        CASE
          WHEN SUM(hp.tiempo_trabajado_min) > 0
          THEN (SUM(hp.unidades_ok) * 60.0) / SUM(hp.tiempo_trabajado_min)
          ELSE 0
        END DESC
      ) as ranking_productividad
    FROM his_prod hp
    INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina
    WHERE hp.fecha >= DATEADD(day, -${days}, GETDATE())
      AND cm.activo = 1
      AND hp.operario IS NOT NULL
      AND hp.operario != ''
      ${machineFilter}
    GROUP BY hp.operario, cm.Cod_maquina
    HAVING SUM(hp.tiempo_trabajado_min) >= 60 -- Al menos 1 hora trabajada
    ORDER BY piezas_por_hora DESC
  `;
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
}
async function getCostAnalysis(machineId, days) {
    const machineFilter = machineId ? `AND cm.Cod_maquina = '${machineId}'` : '';
    const sql = `
    SELECT
      cm.Cod_maquina,
      cm.desc_maquina,
      -- Costos de paradas
      SUM(CASE WHEN cpp.es_planificado = 0 THEN (CAST(hpp.duracion_minutos AS FLOAT) / 60) * ISNULL(cpp.costo_hora_estimado, 150) ELSE 0 END) as costo_paradas_no_planificadas_euros,
      SUM(CASE WHEN cpp.es_planificado = 1 THEN (CAST(hpp.duracion_minutos AS FLOAT) / 60) * ISNULL(cpp.costo_hora_estimado, 75) ELSE 0 END) as costo_paradas_planificadas_euros,
      -- Costos de scrap
      SUM(hp.unidades_nok) * 15.5 as costo_scrap_euros,
      -- Tiempo perdido
      SUM(CASE WHEN cpp.es_planificado = 0 THEN hpp.duracion_minutos ELSE 0 END) as minutos_perdidos_no_planificados,
      -- Cálculo de oportunidad perdida (velocidad nominal vs real)
      SUM(
        CASE
          WHEN hp.velocidad_nominal > hp.velocidad_real AND hp.tiempo_trabajado_min > 0
          THEN ((hp.velocidad_nominal - hp.velocidad_real) / hp.velocidad_nominal) * hp.tiempo_trabajado_min * 2.5 -- €2.5 por minuto de oportunidad
          ELSE 0
        END
      ) as costo_oportunidad_perdida_euros,
      -- Total de costos
      SUM(CASE WHEN cpp.es_planificado = 0 THEN (CAST(hpp.duracion_minutos AS FLOAT) / 60) * ISNULL(cpp.costo_hora_estimado, 150) ELSE 0 END) +
      SUM(hp.unidades_nok) * 15.5 +
      SUM(
        CASE
          WHEN hp.velocidad_nominal > hp.velocidad_real AND hp.tiempo_trabajado_min > 0
          THEN ((hp.velocidad_nominal - hp.velocidad_real) / hp.velocidad_nominal) * hp.tiempo_trabajado_min * 2.5
          ELSE 0
        END
      ) as costo_total_perdidas_euros
    FROM cfg_maquina cm
    LEFT JOIN his_prod_paro hpp ON cm.id_maquina = hpp.id_maquina
      AND hpp.fecha_inicio >= DATEADD(day, -${days}, GETDATE())
    LEFT JOIN cfg_paro cpp ON hpp.id_tipo_paro = cpp.id_paro
    LEFT JOIN his_prod hp ON cm.id_maquina = hp.id_maquina
      AND hp.fecha >= DATEADD(day, -${days}, GETDATE())
    WHERE cm.activo = 1
      ${machineFilter}
    GROUP BY cm.Cod_maquina, cm.desc_maquina
    ORDER BY costo_total_perdidas_euros DESC
  `;
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
}
async function analyzeTrends(historicalData) {
    if (historicalData.length < 2) return {
        trend: 'INSUFICIENTES_DATOS'
    };
    // Análisis de tendencias simples
    const recent = historicalData.slice(0, Math.floor(historicalData.length / 2));
    const older = historicalData.slice(Math.floor(historicalData.length / 2));
    const recentAvgProduction = recent.reduce((sum, item)=>sum + item.total_pieces, 0) / recent.length;
    const olderAvgProduction = older.reduce((sum, item)=>sum + item.total_pieces, 0) / older.length;
    const productionTrend = recentAvgProduction > olderAvgProduction ? 'MEJORANDO' : recentAvgProduction < olderAvgProduction ? 'EMPEORANDO' : 'ESTABLE';
    return {
        production_trend: productionTrend,
        recent_avg_production: recentAvgProduction,
        older_avg_production: olderAvgProduction,
        improvement_percentage: ((recentAvgProduction - olderAvgProduction) / olderAvgProduction * 100).toFixed(2)
    };
}
async function generateInsights(machineId, oeeHistory, downtimeData) {
    const insights = [];
    // Análisis simplificado - apenas insights básicos
    if (downtimeData.length > 0) {
        const totalDowntime = downtimeData.reduce((sum, item)=>sum + (item.duracion_horas || 0), 0);
        insights.push({
            tipo: 'RESUMEN_PAROS',
            prioridad: 'MEDIA',
            mensaje: `Total de tiempo en paros: ${totalDowntime.toFixed(1)} horas`,
            accion_recomendada: 'Revisar eficiencia operacional',
            datos: {
                totalDowntime,
                numParos: downtimeData.length
            }
        });
    }
    if (oeeHistory.length > 0) {
        const avgOEE = oeeHistory.reduce((sum, item)=>sum + (item.oee || 0), 0) / oeeHistory.length;
        insights.push({
            tipo: 'RESUMEN_OEE',
            prioridad: avgOEE < 75 ? 'ALTA' : 'MEDIA',
            mensaje: `OEE promedio: ${avgOEE.toFixed(1)}%`,
            accion_recomendada: avgOEE < 75 ? 'Mejorar disponibilidad, rendimiento y calidad' : 'Mantener el buen rendimiento',
            datos: {
                avgOEE,
                numRegistros: oeeHistory.length
            }
        });
    }
    return insights;
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__87396cd9._.js.map