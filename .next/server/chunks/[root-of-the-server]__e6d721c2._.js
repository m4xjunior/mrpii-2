module.exports = [
"[project]/Downloads/mrpii 2/.next-internal/server/app/api/analytics/insights/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/dns [external] (dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns", () => require("dns"));

module.exports = mod;
}),
"[externals]/constants [external] (constants, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("constants", () => require("constants"));

module.exports = mod;
}),
"[externals]/node:os [external] (node:os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:os", () => require("node:os"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/node:process [external] (node:process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:http [external] (node:http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http", () => require("node:http"));

module.exports = mod;
}),
"[externals]/node:https [external] (node:https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:https", () => require("node:https"));

module.exports = mod;
}),
"[externals]/node:zlib [external] (node:zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:zlib", () => require("node:zlib"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/node:fs/promises [external] (node:fs/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs/promises", () => require("node:fs/promises"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[externals]/node:child_process [external] (node:child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:child_process", () => require("node:child_process"));

module.exports = mod;
}),
"[externals]/dgram [external] (dgram, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dgram", () => require("dgram"));

module.exports = mod;
}),
"[externals]/node:url [external] (node:url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:url", () => require("node:url"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[project]/Downloads/mrpii 2/lib/database/connection.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "closeDbConnection",
    ()=>closeDbConnection,
    "executeQuery",
    ()=>executeQuery,
    "getDbConnection",
    ()=>getDbConnection,
    "testConnections",
    ()=>testConnections
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/node_modules/tedious/lib/tedious.js [app-route] (ecmascript)");
;
// Configuraciones para múltiples bases de datos como en el PHP original
const baseConfig = {
    server: process.env.DB_SERVER || '10.0.0.45',
    authentication: {
        type: 'default',
        options: {
            userName: process.env.DB_USER || 'sa',
            password: process.env.DB_PASSWORD || 'Mapexdd2017'
        }
    },
    options: {
        port: parseInt(process.env.DB_PORT || '1433'),
        encrypt: false,
        trustServerCertificate: true,
        connectTimeout: 30000,
        requestTimeout: 30000,
        enableArithAbort: true
    }
};
// Configuraciones específicas para cada base de datos
const mapexConfig = {
    ...baseConfig,
    options: {
        ...baseConfig.options,
        database: process.env.DB_NAME || 'mapexbp_Test'
    }
};
const sageConfig = {
    ...baseConfig,
    authentication: {
        type: 'default',
        options: {
            userName: 'sa',
            password: 'admin000'
        }
    },
    options: {
        ...baseConfig.options,
        database: 'SAGE'
    }
};
const whalesConfig = {
    ...baseConfig,
    authentication: {
        type: 'default',
        options: {
            userName: 'sa',
            password: '87cc88bb89.'
        }
    },
    options: {
        ...baseConfig.options,
        database: 'WHALES'
    }
};
async function getDbConnection(database = 'mapex') {
    let config;
    switch(database){
        case 'mapex':
            config = mapexConfig;
            break;
        case 'sage':
            config = sageConfig;
            break;
        case 'whales':
            config = whalesConfig;
            break;
        default:
            config = mapexConfig;
    }
    const connection = new __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Connection"](config);
    return new Promise((resolve, reject)=>{
        connection.on('connect', (err)=>{
            if (err) {
                console.error(`❌ Erro ao conectar à base ${database.toUpperCase()}:`, err);
                reject(err);
            } else {
                console.log(`✅ Nova conexão criada para ${database.toUpperCase()}`);
                resolve(connection);
            }
        });
        connection.on('error', (err)=>{
            console.error(`❌ Erro na conexão ${database.toUpperCase()}:`, err);
            reject(err);
        });
        // Não definir on('end') aqui pois vamos fechar manualmente
        connection.connect();
    });
}
async function executeQuery(sql, parameters, database = 'mapex') {
    const conn = await getDbConnection(database);
    return new Promise((resolve, reject)=>{
        const results = [];
        const request = new __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Request"](sql, (err)=>{
            // Sempre fechar a conexão após completar a query
            try {
                conn.close();
            } catch (closeErr) {
                console.warn('⚠️ Erro ao fechar conexão:', closeErr);
            }
            if (err) {
                console.error(`❌ Erro na query ${database.toUpperCase()}:`, err);
                console.error('SQL:', sql.substring(0, 200) + '...');
                reject(err);
            } else {
                resolve(results);
            }
        });
        // Adicionar parâmetros se fornecidos
        if (parameters) {
            Object.entries(parameters).forEach(([key, value])=>{
                let type = __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TYPES"].NVarChar;
                if (typeof value === 'number') {
                    type = Number.isInteger(value) ? __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TYPES"].Int : __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TYPES"].Float;
                } else if (typeof value === 'boolean') {
                    type = __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TYPES"].Bit;
                } else if (value instanceof Date) {
                    type = __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$tedious$2f$lib$2f$tedious$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TYPES"].DateTime;
                }
                request.addParameter(key, type, value);
            });
        }
        request.on('row', (columns)=>{
            const row = {};
            columns.forEach((column)=>{
                row[column.metadata.colName] = column.value;
            });
            results.push(row);
        });
        try {
            conn.execSql(request);
        } catch (execErr) {
            // Se houver erro na execução, fechar conexão e rejeitar
            try {
                conn.close();
            } catch (closeErr) {
                console.warn('⚠️ Erro ao fechar conexão após falha:', closeErr);
            }
            reject(execErr);
        }
    });
}
async function closeDbConnection(database) {
    // Como agora criamos uma nova conexão para cada query e fechamos automaticamente,
    // esta função é mantida por compatibilidade mas não faz mais sentido
    console.log('ℹ️ Conexões agora são gerenciadas automaticamente por query');
}
async function testConnections() {
    const results = {};
    for (const db of [
        'mapex',
        'sage',
        'whales'
    ]){
        try {
            await executeQuery('SELECT 1 as test', undefined, db);
            results[db] = true;
            console.log(`✅ Teste de conectividade ${db.toUpperCase()}: OK`);
        } catch (error) {
            results[db] = false;
            console.error(`❌ Teste de conectividade ${db.toUpperCase()}: FALHOU`, error);
        }
    }
    return results;
}
}),
"[project]/Downloads/mrpii 2/lib/oee/calculations.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "analizarParetoCausas",
    ()=>analizarParetoCausas,
    "calcularOEE",
    ()=>calcularOEE,
    "calcularOEEPonderado",
    ()=>calcularOEEPonderado,
    "calculateOEEForOF",
    ()=>calculateOEEForOF,
    "calculateOEEForTurno",
    ()=>calculateOEEForTurno,
    "calculateProgress",
    ()=>calculateProgress,
    "calculateRemainingTime",
    ()=>calculateRemainingTime,
    "generarAlertas",
    ()=>generarAlertas,
    "getProductionDataForOF",
    ()=>getProductionDataForOF
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/lib/database/connection.ts [app-route] (ecmascript)");
;
async function calculateOEEForOF(machineCode, codOF, daysBack = 10) {
    try {
        // Simular a função F_his_ct() do MAPEX - calcular OEE baseado em dados históricos
        const sql = `
      SELECT
        -- Disponibilidad: tiempo disponible vs tiempo total
        CASE
          WHEN SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN
            ROUND(
              (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) -
               ISNULL(SUM(CASE WHEN hp.id_actividad = 3 THEN CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT) ELSE 0 END), 0)
              ) * 100.0 /
              SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)), 2
            )
          ELSE 0
        END as disponibilidad,

        -- Rendimiento: unidades producidas vs velocidad nominal
        CASE
          WHEN cm.Rt_Rendimientonominal1 > 0 AND SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN
            ROUND(
              (SUM(hp.unidades_ok + hp.unidades_nok) * 3600.0) /
              (cm.Rt_Rendimientonominal1 * (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) / 3600.0)), 2
            )
          ELSE 0
        END as rendimiento,

        -- Calidad: unidades OK vs total producidas
        CASE
          WHEN SUM(hp.unidades_ok + hp.unidades_nok) > 0 THEN
            ROUND((SUM(hp.unidades_ok) * 100.0) / SUM(hp.unidades_ok + hp.unidades_nok), 2)
          ELSE 0
        END as calidad

      FROM cfg_maquina cm
      LEFT JOIN his_fase hf ON cm.rt_id_his_fase = hf.id_his_fase
      LEFT JOIN his_prod hp ON hf.id_his_fase = hp.id_his_fase
      WHERE cm.Cod_maquina = '${machineCode}'
      AND cm.Rt_Cod_of = '${codOF}'
      AND hp.fecha_fin >= DATEADD(DAY, -${daysBack}, GETDATE())
      AND hp.id_actividad = 2 -- Producción
      GROUP BY cm.Rt_Rendimientonominal1 -- Agrupar para agregar correctamente
    `;
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql, undefined, 'mapex');
        if (result.length === 0 || !result[0]) {
            return null;
        }
        const row = result[0];
        const disponibilidad = Math.max(0, Math.min(100, row.disponibilidad || 0));
        const rendimiento = Math.max(0, Math.min(100, row.rendimiento || 0));
        const calidad = Math.max(0, Math.min(100, row.calidad || 0));
        // OEE = Disponibilidad × Rendimiento × Calidad
        const oee = Math.round(disponibilidad * rendimiento * calidad / 10000);
        return {
            oee,
            rendimiento,
            disponibilidad,
            calidad
        };
    } catch (error) {
        console.error('❌ Erro ao calcular OEE para OF:', error);
        return null;
    }
}
async function calculateOEEForTurno(machineCode, diaProductivo) {
    try {
        const sql = `
      SELECT
        -- Disponibilidad del turno
        CASE
          WHEN SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN
            ROUND(
              (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) -
               ISNULL(SUM(CASE WHEN hp.id_actividad = 3 THEN CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT) ELSE 0 END), 0)
              ) * 100.0 /
              SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)), 2
            )
          ELSE 0
        END as disponibilidad,

        -- Rendimiento del turno
        CASE
          WHEN cm.Rt_Rendimientonominal1 > 0 AND SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN
            ROUND(
              (SUM(hp.unidades_ok + hp.unidades_nok) * 3600.0) /
              (cm.Rt_Rendimientonominal1 * (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) / 3600.0)), 2
            )
          ELSE 0
        END as rendimiento,

        -- Calidad del turno
        CASE
          WHEN SUM(hp.unidades_ok + hp.unidades_nok) > 0 THEN
            ROUND((SUM(hp.unidades_ok) * 100.0) / SUM(hp.unidades_ok + hp.unidades_nok), 2)
          ELSE 0
        END as calidad

      FROM cfg_maquina cm
      LEFT JOIN his_fase hf ON cm.rt_id_his_fase = hf.id_his_fase
      LEFT JOIN his_prod hp ON hf.id_his_fase = hp.id_his_fase
      WHERE cm.Cod_maquina = '${machineCode}'
      AND CONVERT(VARCHAR(10), cm.rt_dia_productivo, 111) = '${diaProductivo}'
      AND hp.id_actividad = 2 -- Producción
      GROUP BY cm.Rt_Rendimientonominal1 -- Agrupar para agregar correctamente
    `;
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql, undefined, 'mapex');
        if (result.length === 0 || !result[0]) {
            return null;
        }
        const row = result[0];
        const disponibilidad = Math.max(0, Math.min(100, row.disponibilidad || 0));
        const rendimiento = Math.max(0, Math.min(100, row.rendimiento || 0));
        const calidad = Math.max(0, Math.min(100, row.calidad || 0));
        const oee = Math.round(disponibilidad * rendimiento * calidad / 10000);
        return {
            oee,
            rendimiento,
            disponibilidad,
            calidad
        };
    } catch (error) {
        console.error('❌ Erro ao calcular OEE para turno:', error);
        return null;
    }
}
async function getProductionDataForOF(machineCode, codOF) {
    try {
        const sql = `
      SELECT
        SUM(hp.unidades_ok) as total_ok,
        SUM(hp.unidades_nok) as total_nok,
        SUM(hp.unidades_repro) as total_rw,
        SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) as tiempo_produccion_segundos,
        MIN(hp.fecha_ini) as fecha_inicio_real,
        MAX(hp.fecha_fin) as fecha_fin_real
      FROM his_prod hp
      INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase
      INNER JOIN his_of ho ON hf.id_his_of = ho.id_his_of
      WHERE ho.cod_of = '${codOF}'
      AND hp.id_actividad = 2 -- Producción
    `;
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql, undefined, 'mapex');
        if (result.length === 0 || !result[0]) {
            return null;
        }
        return result[0];
    } catch (error) {
        console.error('❌ Erro ao obter dados de produção:', error);
        return null;
    }
}
function calculateRemainingTime(remainingPieces, velocity) {
    if (velocity > 0 && remainingPieces > 0) {
        const remainingHours = remainingPieces / velocity;
        if (remainingHours >= 24) {
            return `${Math.round(remainingHours / 24)}d`;
        } else {
            return `${remainingHours.toFixed(1)}h`;
        }
    }
    return 'N/A';
}
function calculateProgress(totalProduced, plannedUnits) {
    if (plannedUnits > 0) {
        return Math.round(totalProduced / plannedUnits * 100);
    }
    return 0;
}
async function calcularOEE(machineCode, startDate, endDate) {
    return calculateOEEForOF(machineCode, '', 30); // Simplificado
}
async function calcularOEEPonderado(machineCode, startDate, endDate) {
    const oee = await calculateOEEForOF(machineCode, '', 30);
    return oee?.oee || 0;
}
async function generarAlertas(machineCode) {
    try {
        const oee = await calculateOEEForOF(machineCode, '', 1);
        const alerts = [];
        if (oee) {
            if (oee.oee < 60) {
                alerts.push({
                    type: 'danger',
                    message: 'OEE crítico: abaixo de 60%',
                    value: oee.oee
                });
            } else if (oee.oee < 75) {
                alerts.push({
                    type: 'warning',
                    message: 'OEE baixo: abaixo de 75%',
                    value: oee.oee
                });
            }
            if (oee.disponibilidad < 80) {
                alerts.push({
                    type: 'warning',
                    message: 'Disponibilidade baixa',
                    value: oee.disponibilidad
                });
            }
            if (oee.calidad < 95) {
                alerts.push({
                    type: 'warning',
                    message: 'Qualidade baixa',
                    value: oee.calidad
                });
            }
        }
        return alerts;
    } catch (error) {
        console.error('Erro ao gerar alertas:', error);
        return [];
    }
}
async function analizarParetoCausas(machineCode, startDate, endDate) {
    try {
        const sql = `
      SELECT
        cp.desc_paro as causa,
        SUM(DATEDIFF(MINUTE, hpp.fecha_ini, hpp.fecha_fin)) as tiempo_total_minutos,
        COUNT(*) as cantidad_paros
      FROM his_prod hp
      INNER JOIN his_prod_paro hpp ON hp.id_his_prod = hpp.id_his_prod
      INNER JOIN cfg_paro cp ON hpp.id_paro = cp.id_paro
      INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina
      WHERE cm.Cod_maquina = '${machineCode}'
      AND hpp.fecha_ini >= '${startDate.toISOString()}'
      AND hpp.fecha_ini <= '${endDate.toISOString()}'
      GROUP BY cp.desc_paro
      ORDER BY tiempo_total_minutos DESC
    `;
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql, undefined, 'mapex');
        // Calcular percentual cumulativo (Pareto 80/20)
        const totalTiempo = result.reduce((sum, item)=>sum + (item.tiempo_total_minutos || 0), 0);
        let tiempoAcumulado = 0;
        return result.map((item)=>{
            tiempoAcumulado += item.tiempo_total_minutos || 0;
            return {
                causa: item.causa || 'Sin causa',
                tiempo_total_minutos: item.tiempo_total_minutos || 0,
                cantidad_paros: item.cantidad_paros || 0,
                porcentaje: totalTiempo > 0 ? Math.round(item.tiempo_total_minutos / totalTiempo * 100) : 0,
                porcentaje_acumulado: totalTiempo > 0 ? Math.round(tiempoAcumulado / totalTiempo * 100) : 0
            };
        });
    } catch (error) {
        console.error('Erro ao analisar Pareto de causas:', error);
        return [];
    }
}
}),
"[project]/Downloads/mrpii 2/src/app/api/scada/costs-config/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET,
    "POST",
    ()=>POST,
    "getAllProductCosts",
    ()=>getAllProductCosts,
    "getProductCost",
    ()=>getProductCost
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/lib/database/connection.ts [app-route] (ecmascript)");
;
;
async function getProductCost(cod_producto) {
    try {
        // Consulta simple para obtener costo configurado
        const sql = `
      SELECT TOP 1
        cp.cod_producto,
        0 as costo_default -- Por defecto
      FROM cfg_producto cp
      WHERE cp.cod_producto = @cod_producto
        AND cp.activo = 1
    `;
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql, {
            cod_producto
        });
        if (!result || result.length === 0) {
            console.warn(`⚠️ Producto ${cod_producto} no encontrado, usando costo por defecto €0`);
            return 0;
        }
        // Por ahora, retornar costo por defecto
        // TODO: Implementar tabla de configuración real
        return 0;
    } catch (error) {
        console.error(`❌ Error obteniendo costo para ${cod_producto}:`, error);
        return 0; // Fallback a valor por defecto
    }
}
async function getAllProductCosts() {
    try {
        console.log('💰 Obteniendo todos los costos de productos');
        // Consulta para obtener todos los productos activos
        const sql = `
      SELECT DISTINCT
        cp.cod_producto,
        0 as costo_default -- Por defecto
      FROM cfg_producto cp
      WHERE cp.activo = 1
        AND cp.cod_producto IS NOT NULL
        AND cp.cod_producto != ''
        AND cp.cod_producto != '--'
        AND cp.cod_producto != '{0}'
    `;
        const products = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
        const costMap = {};
        if (products && products.length > 0) {
            products.forEach((product)=>{
                costMap[product.cod_producto] = product.costo_default;
            });
        }
        console.log(`💰 Costos obtenidos para ${Object.keys(costMap).length} productos`);
        return costMap;
    } catch (error) {
        console.error('❌ Error obteniendo todos los costos:', error);
        return {}; // Retornar mapa vacío como fallback
    }
}
async function GET(request) {
    try {
        console.log('⚙️ Obteniendo configuración de costos');
        // Obtener productos con sus máquinas asociadas
        const sql = `
      SELECT DISTINCT
        cp.cod_producto,
        cp.desc_producto,
        cm.Cod_maquina,
        cm.desc_maquina,
        0 as costo_unitario_default -- Sin productos = costo cero
      FROM cfg_producto cp
      LEFT JOIN cfg_maquina cm ON cp.cod_producto = cm.rt_Cod_producto
      WHERE cp.activo = 1
        AND cp.cod_producto IS NOT NULL
        AND cp.cod_producto != ''
        AND cp.cod_producto != '--'
        AND cp.cod_producto != '{0}'
      ORDER BY cp.cod_producto, cm.Cod_maquina
    `;
        const products = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
        // Crear estructura de respuesta
        const costConfig = {};
        products.forEach((product)=>{
            const productKey = product.cod_producto;
            if (!costConfig[productKey]) {
                costConfig[productKey] = {
                    cod_producto: product.cod_producto,
                    desc_producto: product.desc_producto,
                    costo_unitario: product.costo_unitario_default,
                    maquinas: [],
                    nota: 'Costo configurado manualmente (no viene de MAPEX)'
                };
            }
            if (product.Cod_maquina) {
                costConfig[productKey].maquinas.push({
                    cod_maquina: product.Cod_maquina,
                    desc_maquina: product.desc_maquina
                });
            }
        });
        console.log('⚙️ Configuración de costos obtenida:', Object.keys(costConfig).length, 'productos');
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            data: costConfig,
            timestamp: new Date().toISOString(),
            nota: 'Costos por defecto: €0. Configure valores reales usando POST'
        });
    } catch (error) {
        console.error('❌ Error obteniendo configuración de costos:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Error al obtener configuración de costos',
            details: error instanceof Error ? error.message : 'Error desconocido',
            timestamp: new Date().toISOString()
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    try {
        console.log('💾 Configurando costo personalizado');
        const body = await request.json();
        const { cod_producto, costo_unitario, maquina_id } = body;
        if (!cod_producto || costo_unitario === undefined) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Faltan parámetros requeridos: cod_producto y costo_unitario',
                timestamp: new Date().toISOString()
            }, {
                status: 400
            });
        }
        // Validar que el producto existe en MAPEX
        const checkProductSql = `
      SELECT cod_producto, desc_producto
      FROM cfg_producto
      WHERE cod_producto = @cod_producto
        AND activo = 1
    `;
        const productExists = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(checkProductSql, {
            cod_producto
        });
        if (!productExists || productExists.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: `Producto ${cod_producto} no encontrado en MAPEX`,
                timestamp: new Date().toISOString()
            }, {
                status: 404
            });
        }
        // Aquí se podría guardar en una tabla de configuración
        // Por ahora, simularemos el guardado
        console.log('💾 Costo configurado:', {
            cod_producto,
            costo_unitario,
            maquina_id,
            producto: productExists[0].desc_producto
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: `Costo de €${costo_unitario} configurado para producto ${cod_producto}`,
            data: {
                cod_producto,
                costo_unitario: parseFloat(costo_unitario),
                maquina_id,
                producto_descripcion: productExists[0].desc_producto
            },
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('❌ Error configurando costo:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Error al configurar costo',
            details: error instanceof Error ? error.message : 'Error desconocido',
            timestamp: new Date().toISOString()
        }, {
            status: 500
        });
    }
}
}),
"[project]/Downloads/mrpii 2/src/app/api/analytics/insights/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/lib/database/connection.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$oee$2f$calculations$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/lib/oee/calculations.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$src$2f$app$2f$api$2f$scada$2f$costs$2d$config$2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Downloads/mrpii 2/src/app/api/scada/costs-config/route.ts [app-route] (ecmascript)");
;
;
;
;
async function GET(request) {
    try {
        console.log('🧠 Generando insights simplificados');
        // Obtener datos directamente de la API de máquinas que ya funciona
        const machinesResponse = await fetch('http://localhost:3000/api/scada/machines');
        const machinesResult = await machinesResponse.json();
        if (!machinesResult.success || !machinesResult.data) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'No se pudieron obtener datos de las máquinas'
            }, {
                status: 500
            });
        }
        const machinesData = machinesResult.data;
        // Insights básicos para cada máquina
        const machineInsights = machinesData.map((machineData)=>{
            const machine = machineData.machine;
            const totalProduction = (machine.Rt_Unidades_ok || 0) + (machine.Rt_Unidades_nok || 0) + (machine.Rt_Unidades_rw || 0);
            const efficiency = totalProduction > 0 ? (machine.Rt_Unidades_ok || 0) / totalProduction * 100 : 0;
            const alertas = [];
            // Alerta de parada
            if (machineData.status === 'INACTIVA') {
                alertas.push({
                    tipo: 'PARADA',
                    severidad: 'ALTA',
                    mensaje: `Máquina ${machine.Cod_maquina} está inactiva`,
                    recomendacion: 'Verificar y resolver la inactividad'
                });
            }
            // Alerta de baja eficiencia
            if (efficiency < 80 && totalProduction > 10) {
                alertas.push({
                    tipo: 'EFICIENCIA_BAJA',
                    severidad: 'MEDIA',
                    mensaje: `Eficiencia baja en ${machine.Cod_maquina}: ${efficiency.toFixed(1)}%`,
                    recomendacion: 'Revisar parámetros de proceso'
                });
            }
            return {
                machine_id: machine.Cod_maquina,
                machine_name: machine.desc_maquina,
                estado: machineData.status,
                eficiencia_calidad: efficiency,
                progreso_of: machine.Rt_Unidades_planning > 0 ? totalProduction / machine.Rt_Unidades_planning * 100 : 0,
                alertas,
                metricas: {
                    ok: machine.Rt_Unidades_ok || 0,
                    nok: machine.Rt_Unidades_nok || 0,
                    rw: machine.Rt_Unidades_rw || 0,
                    total: totalProduction,
                    velocidad_actual: machineData.velocity?.current || 0,
                    velocidad_nominal: machineData.velocity?.nominal || 0
                }
            };
        });
        // Insights a nivel de planta
        const activeMachines = machinesData.filter((m)=>m.status === 'PRODUCIENDO');
        const inactiveMachines = machinesData.filter((m)=>m.status === 'INACTIVA');
        const totalProduction = machinesData.reduce((sum, m)=>sum + (m.machine?.Rt_Unidades_ok || 0) + (m.machine?.Rt_Unidades_nok || 0) + (m.machine?.Rt_Unidades_rw || 0), 0);
        const totalOK = machinesData.reduce((sum, m)=>sum + (m.machine?.Rt_Unidades_ok || 0), 0);
        const plantInsights = {
            eficiencia_planta: {
                maquinas_activas: activeMachines.length,
                maquinas_inactivas: inactiveMachines.length,
                utilizacion: machinesData.length > 0 ? activeMachines.length / machinesData.length * 100 : 0,
                produccion_total: totalProduction,
                eficiencia_calidad_global: totalProduction > 0 ? totalOK / totalProduction * 100 : 0
            },
            alertas_criticas: inactiveMachines.length,
            eficiencia_promedio: activeMachines.length > 0 ? activeMachines.reduce((sum, m)=>{
                const total = (m.machine?.Rt_Unidades_ok || 0) + (m.machine?.Rt_Unidades_nok || 0) + (m.machine?.Rt_Unidades_rw || 0);
                return sum + (total > 0 ? (m.machine?.Rt_Unidades_ok || 0) / total * 100 : 0);
            }, 0) / activeMachines.length : 0
        };
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            data: {
                timestamp: new Date().toISOString(),
                turno: 'ACTUAL',
                insights_maquinas: machineInsights,
                insights_planta: plantInsights,
                acciones_recomendadas: inactiveMachines.length > 0 ? [
                    {
                        prioridad: 'CRITICA',
                        categoria: 'INACTIVIDAD',
                        descripcion: `${inactiveMachines.length} máquinas inactivas`,
                        accion: 'Resolver inactividad de máquinas',
                        impacto: 'Alto - afecta producción total'
                    }
                ] : [],
                resumen: {
                    total_maquinas: machinesData.length,
                    maquinas_activas: activeMachines.length,
                    maquinas_inactivas: inactiveMachines.length,
                    total_alertas: machineInsights.reduce((sum, m)=>sum + m.alertas.length, 0),
                    eficiencia_promedio_planta: plantInsights.eficiencia_promedio
                }
            }
        });
    } catch (error) {
        console.error('❌ Error generando insights:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Error al generar insights',
            message: error instanceof Error ? error.message : 'Error desconocido'
        }, {
            status: 500
        });
    }
}
async function getCurrentMachinesData() {
    const sql = `
    SELECT
      cm.id_maquina,
      cm.Cod_maquina,
      cm.desc_maquina,
      cm.Rt_Cod_of,
      cm.rt_Cod_producto,
      cm.Rt_Desc_producto,
      cm.Rt_Unidades_planning,
      cm.Rt_Unidades_ok,
      cm.Rt_Unidades_nok,
      cm.Rt_Unidades_rw,
      cm.f_velocidad as velocidad_actual,
      cm.Rt_Rendimientonominal1 as velocidad_nominal,
      cm.rt_desc_turno as turno_actual,
      cm.rt_desc_paro,
      cm.rt_id_paro,
      cm.Rt_Desc_operario as operario_actual,
      -- Estado inferido
      CASE
        WHEN cm.rt_id_paro IS NOT NULL AND cm.rt_id_paro > 0 THEN 'PARADA'
        WHEN cm.Rt_Cod_of IS NOT NULL AND cm.Rt_Cod_of != '--' AND cm.f_velocidad > 0 THEN 'RUN'
        WHEN cm.Rt_Cod_of IS NOT NULL AND cm.Rt_Cod_of != '--' THEN 'IDLE'
        ELSE 'STOPPED'
      END as estado_actual,
      -- Tiempo ciclo ideal (buscar en configuración de producto)
      ISNULL(cp.tiempo_ciclo_ideal_sec, 30) as tiempo_ciclo_ideal_sec,
      -- Metas de OEE
      ISNULL(cm.meta_disponibilidad, 0.85) as meta_disponibilidad,
      ISNULL(cm.meta_rendimiento, 0.80) as meta_rendimiento,
      ISNULL(cm.meta_calidad, 0.95) as meta_calidad,
      ISNULL(cm.meta_oee, 0.65) as meta_oee
    FROM cfg_maquina cm
    LEFT JOIN cfg_producto cp ON cm.rt_Cod_producto = cp.cod_producto
    WHERE cm.activo = 1
      AND cm.Cod_maquina != '--'
    ORDER BY cm.Cod_maquina
  `;
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
}
async function generateMachineInsights(machine) {
    // Obtener paradas del turno actual
    const downtimeEvents = await getMachineDowntimeEvents(machine.id_maquina);
    // Obtener datos de producción del turno
    const productionData = {
        unidades_ok: machine.Rt_Unidades_ok || 0,
        unidades_nok: machine.Rt_Unidades_nok || 0,
        unidades_rw: machine.Rt_Unidades_rw || 0,
        tiempo_ciclo_ideal_sec: machine.tiempo_ciclo_ideal_sec,
        tiempo_planificado_min: 480,
        velocidad_nominal: machine.velocidad_nominal || 100
    };
    // Obtener costos de productos desde MAPEX
    const productCosts = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$src$2f$app$2f$api$2f$scada$2f$costs$2d$config$2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAllProductCosts"])();
    const costoPromedioProducto = Object.keys(productCosts).length > 0 ? Object.values(productCosts).reduce((sum, cost)=>sum + cost, 0) / Object.keys(productCosts).length : 15.50; // Fallback al valor por defecto
    console.log('💰 Costo promedio para insights:', {
        totalProductos: Object.keys(productCosts).length,
        costoPromedio: costoPromedioProducto,
        nota: 'Usado para calcular impacto económico de mejoras OEE'
    });
    // Calcular OEE actual (estimación local con datos disponibles)
    const resultadoOEE = computeOEEFromSnapshot(productionData, downtimeEvents, {
        velocidad_actual: machine.velocidad_actual || 0,
        velocidad_nominal: machine.velocidad_nominal || 0,
        tiempo_planificado_min: 480
    });
    // Generar alertas
    const alertas = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$oee$2f$calculations$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generarAlertas"])(machine.Cod_maquina);
    // Calcular ETA si hay OF activa
    let eta = null;
    if (machine.Rt_Cod_of && machine.Rt_Cod_of !== '--' && machine.Rt_Unidades_planning > 0) {
        const unidades_faltantes = machine.Rt_Unidades_planning - (productionData.unidades_ok + productionData.unidades_nok + productionData.unidades_rw);
        const velocidad_promedio = machine.velocidad_actual || 0;
        if (unidades_faltantes > 0 && velocidad_promedio > 0) {
            const horas_restantes = unidades_faltantes / velocidad_promedio;
            eta = new Date(Date.now() + horas_restantes * 60 * 60 * 1000);
        }
    }
    // Análisis de rendimiento vs histórico
    const performanceAnalysis = await analyzePerformanceVsHistorical(machine.id_maquina);
    // Detección de patrones anómalos
    const anomalies = await detectAnomalies(machine);
    return {
        estado: machine.estado_actual,
        oee_actual: resultadoOEE,
        alertas,
        eta_of: eta,
        analisis_rendimiento: performanceAnalysis,
        anomalias: anomalies,
        recomendaciones: generateMachineRecommendations(machine, resultadoOEE, alertas),
        metricas_turno: {
            progreso_of: machine.Rt_Unidades_planning > 0 ? (productionData.unidades_ok + productionData.unidades_nok + productionData.unidades_rw) / machine.Rt_Unidades_planning * 100 : 0,
            eficiencia_calidad: productionData.unidades_ok + productionData.unidades_nok + productionData.unidades_rw > 0 ? productionData.unidades_ok / (productionData.unidades_ok + productionData.unidades_nok + productionData.unidades_rw) * 100 : 0,
            velocidad_vs_nominal: machine.velocidad_nominal > 0 ? machine.velocidad_actual / machine.velocidad_nominal * 100 : 0
        }
    };
}
function computeOEEFromSnapshot(prod, downtimeEvents, ctx) {
    const total = (prod.unidades_ok || 0) + (prod.unidades_nok || 0) + (prod.unidades_rw || 0);
    const calidad = total > 0 ? prod.unidades_ok / total : 0;
    const disponibilidad = ctx.tiempo_planificado_min > 0 ? Math.max(0, Math.min(1, 1 - downtimeEvents.reduce((s, e)=>s + (e.duracion_sec || 0), 0) / 60 / ctx.tiempo_planificado_min)) : 0;
    const rendimiento = ctx.velocidad_nominal > 0 ? Math.max(0, Math.min(1, ctx.velocidad_actual / ctx.velocidad_nominal)) : 0;
    const oee = disponibilidad * rendimiento * calidad;
    return {
        oee,
        rendimiento,
        disponibilidad,
        calidad
    };
}
async function getMachineDowntimeEvents(machineId) {
    const sql = `
    SELECT
      hpp.duracion_minutos * 60 as duracion_sec,
      hpp.tipo_paro as tipo,
      hpp.desc_paro as causa,
      CASE WHEN cp.es_planificado = 1 THEN 1 ELSE 0 END as es_planificada,
      hpp.fecha_inicio as hora_inicio,
      hpp.fecha_fin as hora_fin
    FROM his_prod_paro hpp
    LEFT JOIN cfg_paro cp ON hpp.id_tipo_paro = cp.id_paro
    WHERE hpp.id_maquina = ${machineId}
      AND hpp.fecha_inicio >= CAST(GETDATE() AS DATE) -- Solo hoy
    ORDER BY hpp.fecha_inicio DESC
  `;
    const results = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
    return results.map((row)=>({
            duracion_sec: row.duracion_sec || 0,
            tipo: row.tipo || 'DESCONOCIDO',
            causa: row.causa,
            es_planificada: row.es_planificada === 1,
            hora_inicio: new Date(row.hora_inicio),
            hora_fin: row.hora_fin ? new Date(row.hora_fin) : undefined
        }));
}
async function analyzePerformanceVsHistorical(machineId) {
    const sql = `
    SELECT
      AVG(CAST(oee AS FLOAT)) as oee_promedio_7d,
      AVG(CAST(disponibilidad AS FLOAT)) as disponibilidad_promedio_7d,
      AVG(CAST(rendimiento AS FLOAT)) as rendimiento_promedio_7d,
      AVG(CAST(calidad AS FLOAT)) as calidad_promedio_7d,
      COUNT(*) as mediciones
    FROM his_horaOEE
    WHERE id_maquina = ${machineId}
      AND fecha >= DATEADD(day, -7, GETDATE())
  `;
    const historical = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Downloads$2f$mrpii__2$2f$lib$2f$database$2f$connection$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(sql);
    return historical[0] || {};
}
async function detectAnomalies(machine) {
    const anomalies = [];
    // Anomalía: Velocidad muy baja comparada con nominal
    if (machine.velocidad_actual > 0 && machine.velocidad_nominal > 0) {
        const velocityRatio = machine.velocidad_actual / machine.velocidad_nominal;
        if (velocityRatio < 0.5) {
            anomalies.push({
                tipo: 'VELOCIDAD_ANOMALA',
                severidad: 'ALTA',
                descripcion: `Velocidad actual (${machine.velocidad_actual}) muy por debajo de la nominal (${machine.velocidad_nominal})`,
                valor_actual: machine.velocidad_actual,
                valor_esperado: machine.velocidad_nominal
            });
        }
    }
    // Anomalía: Alto ratio de NOK
    const totalProduced = (machine.Rt_Unidades_ok || 0) + (machine.Rt_Unidades_nok || 0) + (machine.Rt_Unidades_rw || 0);
    if (totalProduced > 10) {
        const nokRatio = (machine.Rt_Unidades_nok || 0) / totalProduced;
        if (nokRatio > 0.10) {
            anomalies.push({
                tipo: 'CALIDAD_ANOMALA',
                severidad: nokRatio > 0.20 ? 'CRITICA' : 'ALTA',
                descripcion: `Ratio de piezas NOK elevado: ${(nokRatio * 100).toFixed(1)}%`,
                valor_actual: nokRatio * 100,
                valor_esperado: 5
            });
        }
    }
    return anomalies;
}
function generateMachineRecommendations(machine, oeeResult, alertas) {
    const recommendations = [];
    // Recomendación basada en disponibilidad
    if (oeeResult.disponibilidad < 0.80) {
        recommendations.push({
            categoria: 'DISPONIBILIDAD',
            prioridad: 'ALTA',
            accion: 'Reducir tiempo de paradas no planificadas',
            detalle: `Tiempo perdido: ${Math.round(oeeResult.tiempo_paradas_no_planificadas_sec / 60)} minutos`,
            impacto_estimado: `+${((0.85 - oeeResult.disponibilidad) * 8 * 120).toFixed(0)} piezas/turno`
        });
    }
    // Recomendación basada en rendimiento
    if (oeeResult.rendimiento < 0.75) {
        recommendations.push({
            categoria: 'RENDIMIENTO',
            prioridad: 'MEDIA',
            accion: 'Optimizar velocidad de máquina',
            detalle: 'Verificar parámetros de proceso y eliminar microparadas',
            impacto_estimado: `+${((0.80 - oeeResult.rendimiento) * 480 * 2).toFixed(0)} piezas/turno`
        });
    }
    // Recomendación basada en calidad
    if (oeeResult.calidad < 0.90) {
        recommendations.push({
            categoria: 'CALIDAD',
            prioridad: 'ALTA',
            accion: 'Revisar parámetros de calidad',
            detalle: 'Calibrar equipos y verificar materias primas',
            impacto_estimado: `Ahorro: €${((1 - oeeResult.calidad) * 100 * 15.5).toFixed(2)}/turno`
        });
    }
    return recommendations;
}
async function generatePlantInsights(machinesData) {
    const activesMachines = machinesData.filter((m)=>[
            'RUN',
            'IDLE',
            'SETUP'
        ].includes(m.estado_actual));
    const runningMachines = machinesData.filter((m)=>m.estado_actual === 'RUN');
    // OEE ponderado de máquinas activas
    const totalProduction = activesMachines.reduce((sum, m)=>sum + (m.Rt_Unidades_ok || 0) + (m.Rt_Unidades_nok || 0) + (m.Rt_Unidades_rw || 0), 0);
    return {
        eficiencia_planta: {
            maquinas_activas: activesMachines.length,
            maquinas_produciendo: runningMachines.length,
            utilizacion: machinesData.length > 0 ? activesMachines.length / machinesData.length * 100 : 0,
            produccion_total_turno: totalProduction
        },
        cuello_botella: identifyBottleneck(activesMachines),
        oportunidades_mejora: identifyImprovementOpportunities(machinesData),
        balance_linea: analyzeLineBalance(activesMachines)
    };
}
function identifyBottleneck(machines) {
    // Identificar máquina con menor velocidad relativa
    const machinesWithVelocity = machines.filter((m)=>m.velocidad_actual > 0 && m.velocidad_nominal > 0);
    if (machinesWithVelocity.length === 0) return null;
    const bottleneck = machinesWithVelocity.reduce((min, machine)=>{
        const ratio = machine.velocidad_actual / machine.velocidad_nominal;
        const minRatio = min.velocidad_actual / min.velocidad_nominal;
        return ratio < minRatio ? machine : min;
    });
    return {
        maquina: bottleneck.Cod_maquina,
        velocidad_relativa: (bottleneck.velocidad_actual / bottleneck.velocidad_nominal * 100).toFixed(1),
        impacto_estimado: 'Limita capacidad de toda la línea'
    };
}
function identifyImprovementOpportunities(machines) {
    const opportunities = [];
    // Oportunidad: Máquinas paradas con OF pendiente
    const stoppedWithWork = machines.filter((m)=>m.estado_actual === 'PARADA' && m.Rt_Cod_of && m.Rt_Cod_of !== '--');
    if (stoppedWithWork.length > 0) {
        opportunities.push({
            tipo: 'REACTIVACION_RAPIDA',
            maquinas_afectadas: stoppedWithWork.length,
            impacto: 'ALTO',
            descripcion: `${stoppedWithWork.length} máquinas paradas con OF pendiente`,
            accion: 'Priorizar reanudación de estas máquinas'
        });
    }
    // Oportunidad: Desbalance de carga
    const loadImbalance = calculateLoadImbalance(machines);
    if (loadImbalance.coefficient > 0.3) {
        opportunities.push({
            tipo: 'BALANCE_CARGA',
            impacto: 'MEDIO',
            descripcion: 'Distribución desigual de carga entre máquinas',
            accion: 'Redistribuir órdenes de fabricación',
            coeficiente_variacion: loadImbalance.coefficient
        });
    }
    return opportunities;
}
function calculateLoadImbalance(machines) {
    const loads = machines.map((m)=>(m.Rt_Unidades_ok || 0) + (m.Rt_Unidades_nok || 0) + (m.Rt_Unidades_rw || 0));
    const mean = loads.reduce((sum, load)=>sum + load, 0) / loads.length;
    const variance = loads.reduce((sum, load)=>sum + Math.pow(load - mean, 2), 0) / loads.length;
    const stdDev = Math.sqrt(variance);
    return {
        coefficient: mean > 0 ? stdDev / mean : 0,
        mean_load: mean,
        std_deviation: stdDev
    };
}
function analyzeLineBalance(machines) {
    if (machines.length === 0) return null;
    const velocities = machines.filter((m)=>m.velocidad_actual > 0).map((m)=>m.velocidad_actual);
    if (velocities.length === 0) return null;
    const minVelocity = Math.min(...velocities);
    const maxVelocity = Math.max(...velocities);
    const avgVelocity = velocities.reduce((sum, v)=>sum + v, 0) / velocities.length;
    return {
        velocidad_minima: minVelocity,
        velocidad_maxima: maxVelocity,
        velocidad_promedio: avgVelocity,
        desbalance_porcentaje: maxVelocity > 0 ? (maxVelocity - minVelocity) / maxVelocity * 100 : 0,
        estado: maxVelocity > 0 && (maxVelocity - minVelocity) / maxVelocity < 0.1 ? 'BALANCEADO' : 'DESBALANCEADO'
    };
}
async function generateActionableInsights(machinesData) {
    const actions = [];
    // Acciones para máquinas con alertas críticas
    const criticalMachines = machinesData.filter((m)=>m.estado_actual === 'PARADA' || (m.Rt_Unidades_nok || 0) / ((m.Rt_Unidades_ok || 0) + (m.Rt_Unidades_nok || 0) + 1) > 0.15);
    for (const machine of criticalMachines){
        if (machine.estado_actual === 'PARADA') {
            actions.push({
                maquina: machine.Cod_maquina,
                prioridad: 'CRITICA',
                categoria: 'PARADA_PROLONGADA',
                accion: 'Investigar y resolver parada inmediatamente',
                tiempo_estimado: '15-30 min',
                responsable: 'Técnico de turno'
            });
        }
    }
    return actions;
}
async function calculateConsolidatedKPIs(machinesData) {
    const activeMachines = machinesData.filter((m)=>[
            'RUN',
            'IDLE',
            'SETUP'
        ].includes(m.estado_actual));
    const totalProduction = machinesData.reduce((sum, m)=>sum + (m.Rt_Unidades_ok || 0) + (m.Rt_Unidades_nok || 0) + (m.Rt_Unidades_rw || 0), 0);
    const totalOK = machinesData.reduce((sum, m)=>sum + (m.Rt_Unidades_ok || 0), 0);
    return {
        utilizacion_planta: machinesData.length > 0 ? activeMachines.length / machinesData.length * 100 : 0,
        produccion_total: totalProduction,
        eficiencia_calidad_global: totalProduction > 0 ? totalOK / totalProduction * 100 : 0,
        maquinas_criticas: machinesData.filter((m)=>m.estado_actual === 'PARADA').length,
        velocidad_promedio_planta: activeMachines.length > 0 ? activeMachines.reduce((sum, m)=>sum + (m.velocidad_actual || 0), 0) / activeMachines.length : 0
    };
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__e6d721c2._.js.map