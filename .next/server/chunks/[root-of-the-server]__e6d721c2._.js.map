{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/lib/database/connection.ts"],"sourcesContent":["import { Connection, Request, TYPES } from 'tedious';\n\n// Configuraciones para múltiples bases de datos como en el PHP original\nconst baseConfig: any = {\n  server: process.env.DB_SERVER || '10.0.0.45',\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: process.env.DB_USER || 'sa',\n      password: process.env.DB_PASSWORD || 'Mapexdd2017',\n    },\n  },\n  options: {\n    port: parseInt(process.env.DB_PORT || '1433'),\n    encrypt: false,\n    trustServerCertificate: true,\n    connectTimeout: 30000,\n    requestTimeout: 30000,\n    enableArithAbort: true,\n  },\n};\n\n// Configuraciones específicas para cada base de datos\nconst mapexConfig: any = {\n  ...baseConfig,\n  options: {\n    ...baseConfig.options,\n    database: process.env.DB_NAME || 'mapexbp_Test',\n  },\n};\n\nconst sageConfig: any = {\n  ...baseConfig,\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: 'sa',\n      password: 'admin000',\n    },\n  },\n  options: {\n    ...baseConfig.options,\n    database: 'SAGE',\n  },\n};\n\nconst whalesConfig: any = {\n  ...baseConfig,\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: 'sa',\n      password: '87cc88bb89.',\n    },\n  },\n  options: {\n    ...baseConfig.options,\n    database: 'WHALES',\n  },\n};\n\n// Função para criar uma nova conexão para cada query (evita conflitos de estado)\nexport async function getDbConnection(database: 'mapex' | 'sage' | 'whales' = 'mapex'): Promise<Connection> {\n  let config: any;\n  switch (database) {\n    case 'mapex':\n      config = mapexConfig;\n      break;\n    case 'sage':\n      config = sageConfig;\n      break;\n    case 'whales':\n      config = whalesConfig;\n      break;\n    default:\n      config = mapexConfig;\n  }\n\n  const connection = new Connection(config);\n\n  return new Promise((resolve, reject) => {\n    connection.on('connect', (err) => {\n      if (err) {\n        console.error(`❌ Erro ao conectar à base ${database.toUpperCase()}:`, err);\n        reject(err);\n      } else {\n        console.log(`✅ Nova conexão criada para ${database.toUpperCase()}`);\n        resolve(connection);\n      }\n    });\n\n    connection.on('error', (err) => {\n      console.error(`❌ Erro na conexão ${database.toUpperCase()}:`, err);\n      reject(err);\n    });\n\n    // Não definir on('end') aqui pois vamos fechar manualmente\n\n    connection.connect();\n  });\n}\n\nexport async function executeQuery<T = any>(\n  sql: string,\n  parameters?: { [key: string]: any },\n  database: 'mapex' | 'sage' | 'whales' = 'mapex'\n): Promise<T[]> {\n  const conn = await getDbConnection(database);\n\n  return new Promise((resolve, reject) => {\n    const results: T[] = [];\n\n    const request = new Request(sql, (err) => {\n      // Sempre fechar a conexão após completar a query\n      try {\n        conn.close();\n      } catch (closeErr) {\n        console.warn('⚠️ Erro ao fechar conexão:', closeErr);\n      }\n\n      if (err) {\n        console.error(`❌ Erro na query ${database.toUpperCase()}:`, err);\n        console.error('SQL:', sql.substring(0, 200) + '...');\n        reject(err);\n      } else {\n        resolve(results);\n      }\n    });\n\n    // Adicionar parâmetros se fornecidos\n    if (parameters) {\n      Object.entries(parameters).forEach(([key, value]) => {\n        let type: any = TYPES.NVarChar;\n        if (typeof value === 'number') {\n          type = Number.isInteger(value) ? TYPES.Int : TYPES.Float;\n        } else if (typeof value === 'boolean') {\n          type = TYPES.Bit;\n        } else if (value instanceof Date) {\n          type = TYPES.DateTime;\n        }\n        request.addParameter(key, type, value);\n      });\n    }\n\n    request.on('row', (columns: any) => {\n      const row: any = {};\n      columns.forEach((column: any) => {\n        row[column.metadata.colName] = column.value;\n      });\n      results.push(row);\n    });\n\n    try {\n      conn.execSql(request);\n    } catch (execErr) {\n      // Se houver erro na execução, fechar conexão e rejeitar\n      try {\n        conn.close();\n      } catch (closeErr) {\n        console.warn('⚠️ Erro ao fechar conexão após falha:', closeErr);\n      }\n      reject(execErr);\n    }\n  });\n}\n\nexport async function closeDbConnection(database?: 'mapex' | 'sage' | 'whales'): Promise<void> {\n  // Como agora criamos uma nova conexão para cada query e fechamos automaticamente,\n  // esta função é mantida por compatibilidade mas não faz mais sentido\n  console.log('ℹ️ Conexões agora são gerenciadas automaticamente por query');\n}\n\n// Função para testar conectividade\nexport async function testConnections(): Promise<{ [key: string]: boolean }> {\n  const results: { [key: string]: boolean } = {};\n\n  for (const db of ['mapex', 'sage', 'whales'] as const) {\n    try {\n      await executeQuery('SELECT 1 as test', undefined, db);\n      results[db] = true;\n      console.log(`✅ Teste de conectividade ${db.toUpperCase()}: OK`);\n    } catch (error) {\n      results[db] = false;\n      console.error(`❌ Teste de conectividade ${db.toUpperCase()}: FALHOU`, error);\n    }\n  }\n\n  return results;\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/lib/oee/calculations.ts"],"sourcesContent":["import { executeQuery } from '../database/connection';\n\nexport interface OEECalculation {\n  oee: number;\n  rendimiento: number;\n  disponibilidad: number;\n  calidad: number;\n}\n\nexport interface ProductionData {\n  total_ok: number;\n  total_nok: number;\n  total_rw: number;\n  tiempo_produccion_segundos: number;\n  fecha_inicio_real: string | null;\n  fecha_fin_real: string | null;\n}\n\n/**\n * Calcula OEE usando a função F_his_ct() do MAPEX (simulada)\n * Esta função simula o comportamento da função F_his_ct('WORKCENTER','','OF',...) do MAPEX\n */\nexport async function calculateOEEForOF(\n  machineCode: string,\n  codOF: string,\n  daysBack: number = 10\n): Promise<OEECalculation | null> {\n  try {\n    // Simular a função F_his_ct() do MAPEX - calcular OEE baseado em dados históricos\n    const sql = `\n      SELECT\n        -- Disponibilidad: tiempo disponible vs tiempo total\n        CASE\n          WHEN SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) -\n               ISNULL(SUM(CASE WHEN hp.id_actividad = 3 THEN CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT) ELSE 0 END), 0)\n              ) * 100.0 /\n              SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)), 2\n            )\n          ELSE 0\n        END as disponibilidad,\n\n        -- Rendimiento: unidades producidas vs velocidad nominal\n        CASE\n          WHEN cm.Rt_Rendimientonominal1 > 0 AND SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(hp.unidades_ok + hp.unidades_nok) * 3600.0) /\n              (cm.Rt_Rendimientonominal1 * (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) / 3600.0)), 2\n            )\n          ELSE 0\n        END as rendimiento,\n\n        -- Calidad: unidades OK vs total producidas\n        CASE\n          WHEN SUM(hp.unidades_ok + hp.unidades_nok) > 0 THEN\n            ROUND((SUM(hp.unidades_ok) * 100.0) / SUM(hp.unidades_ok + hp.unidades_nok), 2)\n          ELSE 0\n        END as calidad\n\n      FROM cfg_maquina cm\n      LEFT JOIN his_fase hf ON cm.rt_id_his_fase = hf.id_his_fase\n      LEFT JOIN his_prod hp ON hf.id_his_fase = hp.id_his_fase\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND cm.Rt_Cod_of = '${codOF}'\n      AND hp.fecha_fin >= DATEADD(DAY, -${daysBack}, GETDATE())\n      AND hp.id_actividad = 2 -- Producción\n      GROUP BY cm.Rt_Rendimientonominal1 -- Agrupar para agregar correctamente\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    const row = result[0];\n    const disponibilidad = Math.max(0, Math.min(100, row.disponibilidad || 0));\n    const rendimiento = Math.max(0, Math.min(100, row.rendimiento || 0));\n    const calidad = Math.max(0, Math.min(100, row.calidad || 0));\n\n    // OEE = Disponibilidad × Rendimiento × Calidad\n    const oee = Math.round((disponibilidad * rendimiento * calidad) / 10000);\n\n    return {\n      oee,\n      rendimiento,\n      disponibilidad,\n      calidad\n    };\n  } catch (error) {\n    console.error('❌ Erro ao calcular OEE para OF:', error);\n    return null;\n  }\n}\n\n/**\n * Calcula OEE por turno usando simulação da função F_his_ct('WORKCENTER','DAY','TURNO',...)\n */\nexport async function calculateOEEForTurno(\n  machineCode: string,\n  diaProductivo: string\n): Promise<OEECalculation | null> {\n  try {\n    const sql = `\n      SELECT\n        -- Disponibilidad del turno\n        CASE\n          WHEN SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) -\n               ISNULL(SUM(CASE WHEN hp.id_actividad = 3 THEN CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT) ELSE 0 END), 0)\n              ) * 100.0 /\n              SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)), 2\n            )\n          ELSE 0\n        END as disponibilidad,\n\n        -- Rendimiento del turno\n        CASE\n          WHEN cm.Rt_Rendimientonominal1 > 0 AND SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(hp.unidades_ok + hp.unidades_nok) * 3600.0) /\n              (cm.Rt_Rendimientonominal1 * (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) / 3600.0)), 2\n            )\n          ELSE 0\n        END as rendimiento,\n\n        -- Calidad del turno\n        CASE\n          WHEN SUM(hp.unidades_ok + hp.unidades_nok) > 0 THEN\n            ROUND((SUM(hp.unidades_ok) * 100.0) / SUM(hp.unidades_ok + hp.unidades_nok), 2)\n          ELSE 0\n        END as calidad\n\n      FROM cfg_maquina cm\n      LEFT JOIN his_fase hf ON cm.rt_id_his_fase = hf.id_his_fase\n      LEFT JOIN his_prod hp ON hf.id_his_fase = hp.id_his_fase\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND CONVERT(VARCHAR(10), cm.rt_dia_productivo, 111) = '${diaProductivo}'\n      AND hp.id_actividad = 2 -- Producción\n      GROUP BY cm.Rt_Rendimientonominal1 -- Agrupar para agregar correctamente\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    const row = result[0];\n    const disponibilidad = Math.max(0, Math.min(100, row.disponibilidad || 0));\n    const rendimiento = Math.max(0, Math.min(100, row.rendimiento || 0));\n    const calidad = Math.max(0, Math.min(100, row.calidad || 0));\n\n    const oee = Math.round((disponibilidad * rendimiento * calidad) / 10000);\n\n    return {\n      oee,\n      rendimiento,\n      disponibilidad,\n      calidad\n    };\n  } catch (error) {\n    console.error('❌ Erro ao calcular OEE para turno:', error);\n    return null;\n  }\n}\n\n/**\n * Obtém dados de produção detalhados para uma OF\n */\nexport async function getProductionDataForOF(\n  machineCode: string,\n  codOF: string\n): Promise<ProductionData | null> {\n  try {\n    const sql = `\n      SELECT\n        SUM(hp.unidades_ok) as total_ok,\n        SUM(hp.unidades_nok) as total_nok,\n        SUM(hp.unidades_repro) as total_rw,\n        SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) as tiempo_produccion_segundos,\n        MIN(hp.fecha_ini) as fecha_inicio_real,\n        MAX(hp.fecha_fin) as fecha_fin_real\n      FROM his_prod hp\n      INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase\n      INNER JOIN his_of ho ON hf.id_his_of = ho.id_his_of\n      WHERE ho.cod_of = '${codOF}'\n      AND hp.id_actividad = 2 -- Producción\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    return result[0] as ProductionData;\n  } catch (error) {\n    console.error('❌ Erro ao obter dados de produção:', error);\n    return null;\n  }\n}\n\n/**\n * Calcula tempo restante para completar uma OF\n */\nexport function calculateRemainingTime(\n  remainingPieces: number,\n  velocity: number\n): string {\n  if (velocity > 0 && remainingPieces > 0) {\n    const remainingHours = remainingPieces / velocity;\n    if (remainingHours >= 24) {\n      return `${Math.round(remainingHours / 24)}d`;\n    } else {\n      return `${remainingHours.toFixed(1)}h`;\n    }\n  }\n  return 'N/A';\n}\n\n/**\n * Calcula percentual de avanço de uma OF\n */\nexport function calculateProgress(\n  totalProduced: number,\n  plannedUnits: number\n): number {\n  if (plannedUnits > 0) {\n    return Math.round((totalProduced / plannedUnits) * 100);\n  }\n  return 0;\n}\n\n/**\n * Calcula OEE (função de compatibilidade)\n */\nexport async function calcularOEE(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<OEECalculation | null> {\n  return calculateOEEForOF(machineCode, '', 30); // Simplificado\n}\n\n/**\n * Calcula OEE ponderado (função de compatibilidade)\n */\nexport async function calcularOEEPonderado(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<number> {\n  const oee = await calculateOEEForOF(machineCode, '', 30);\n  return oee?.oee || 0;\n}\n\n/**\n * Gera alertas baseado em dados OEE (função de compatibilidade)\n */\nexport async function generarAlertas(\n  machineCode: string\n): Promise<any[]> {\n  try {\n    const oee = await calculateOEEForOF(machineCode, '', 1);\n    const alerts = [];\n\n    if (oee) {\n      if (oee.oee < 60) {\n        alerts.push({\n          type: 'danger',\n          message: 'OEE crítico: abaixo de 60%',\n          value: oee.oee\n        });\n      } else if (oee.oee < 75) {\n        alerts.push({\n          type: 'warning',\n          message: 'OEE baixo: abaixo de 75%',\n          value: oee.oee\n        });\n      }\n\n      if (oee.disponibilidad < 80) {\n        alerts.push({\n          type: 'warning',\n          message: 'Disponibilidade baixa',\n          value: oee.disponibilidad\n        });\n      }\n\n      if (oee.calidad < 95) {\n        alerts.push({\n          type: 'warning',\n          message: 'Qualidade baixa',\n          value: oee.calidad\n        });\n      }\n    }\n\n    return alerts;\n  } catch (error) {\n    console.error('Erro ao gerar alertas:', error);\n    return [];\n  }\n}\n\n/**\n * Análise Pareto de causas de paros\n */\nexport async function analizarParetoCausas(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<any[]> {\n  try {\n    const sql = `\n      SELECT\n        cp.desc_paro as causa,\n        SUM(DATEDIFF(MINUTE, hpp.fecha_ini, hpp.fecha_fin)) as tiempo_total_minutos,\n        COUNT(*) as cantidad_paros\n      FROM his_prod hp\n      INNER JOIN his_prod_paro hpp ON hp.id_his_prod = hpp.id_his_prod\n      INNER JOIN cfg_paro cp ON hpp.id_paro = cp.id_paro\n      INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND hpp.fecha_ini >= '${startDate.toISOString()}'\n      AND hpp.fecha_ini <= '${endDate.toISOString()}'\n      GROUP BY cp.desc_paro\n      ORDER BY tiempo_total_minutos DESC\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    // Calcular percentual cumulativo (Pareto 80/20)\n    const totalTiempo = result.reduce((sum, item) => sum + (item.tiempo_total_minutos || 0), 0);\n    let tiempoAcumulado = 0;\n\n    return result.map(item => {\n      tiempoAcumulado += item.tiempo_total_minutos || 0;\n      return {\n        causa: item.causa || 'Sin causa',\n        tiempo_total_minutos: item.tiempo_total_minutos || 0,\n        cantidad_paros: item.cantidad_paros || 0,\n        porcentaje: totalTiempo > 0 ? Math.round((item.tiempo_total_minutos / totalTiempo) * 100) : 0,\n        porcentaje_acumulado: totalTiempo > 0 ? Math.round((tiempoAcumulado / totalTiempo) * 100) : 0\n      };\n    });\n  } catch (error) {\n    console.error('Erro ao analisar Pareto de causas:', error);\n    return [];\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 698, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/src/app/api/scada/costs-config/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { executeQuery } from '../../../../../lib/database/connection';\n\n// Función utilitaria para obtener costo de un producto\nexport async function getProductCost(cod_producto: string): Promise<number> {\n  try {\n    // Consulta simple para obtener costo configurado\n    const sql = `\n      SELECT TOP 1\n        cp.cod_producto,\n        0 as costo_default -- Por defecto\n      FROM cfg_producto cp\n      WHERE cp.cod_producto = @cod_producto\n        AND cp.activo = 1\n    `;\n\n    const result = await executeQuery(sql, { cod_producto });\n\n    if (!result || result.length === 0) {\n      console.warn(`⚠️ Producto ${cod_producto} no encontrado, usando costo por defecto €0`);\n      return 0;\n    }\n\n    // Por ahora, retornar costo por defecto\n    // TODO: Implementar tabla de configuración real\n    return 0;\n\n  } catch (error) {\n    console.error(`❌ Error obteniendo costo para ${cod_producto}:`, error);\n    return 0; // Fallback a valor por defecto\n  }\n}\n\n// Función para obtener todos los costos de productos para cálculos mensuales\nexport async function getAllProductCosts(): Promise<{ [key: string]: number }> {\n  try {\n    console.log('💰 Obteniendo todos los costos de productos');\n\n    // Consulta para obtener todos los productos activos\n    const sql = `\n      SELECT DISTINCT\n        cp.cod_producto,\n        0 as costo_default -- Por defecto\n      FROM cfg_producto cp\n      WHERE cp.activo = 1\n        AND cp.cod_producto IS NOT NULL\n        AND cp.cod_producto != ''\n        AND cp.cod_producto != '--'\n        AND cp.cod_producto != '{0}'\n    `;\n\n    const products = await executeQuery(sql);\n    const costMap: { [key: string]: number } = {};\n\n    if (products && products.length > 0) {\n      products.forEach((product: any) => {\n        costMap[product.cod_producto] = product.costo_default;\n      });\n    }\n\n    console.log(`💰 Costos obtenidos para ${Object.keys(costMap).length} productos`);\n    return costMap;\n\n  } catch (error) {\n    console.error('❌ Error obteniendo todos los costos:', error);\n    return {}; // Retornar mapa vacío como fallback\n  }\n}\n\n// API para configurar costos por producto/máquina\nexport async function GET(request: NextRequest) {\n  try {\n    console.log('⚙️ Obteniendo configuración de costos');\n\n    // Obtener productos con sus máquinas asociadas\n    const sql = `\n      SELECT DISTINCT\n        cp.cod_producto,\n        cp.desc_producto,\n        cm.Cod_maquina,\n        cm.desc_maquina,\n        0 as costo_unitario_default -- Sin productos = costo cero\n      FROM cfg_producto cp\n      LEFT JOIN cfg_maquina cm ON cp.cod_producto = cm.rt_Cod_producto\n      WHERE cp.activo = 1\n        AND cp.cod_producto IS NOT NULL\n        AND cp.cod_producto != ''\n        AND cp.cod_producto != '--'\n        AND cp.cod_producto != '{0}'\n      ORDER BY cp.cod_producto, cm.Cod_maquina\n    `;\n\n    const products = await executeQuery(sql);\n\n    // Crear estructura de respuesta\n    const costConfig: { [key: string]: any } = {};\n\n    products.forEach((product: any) => {\n      const productKey = product.cod_producto;\n\n      if (!costConfig[productKey]) {\n        costConfig[productKey] = {\n          cod_producto: product.cod_producto,\n          desc_producto: product.desc_producto,\n          costo_unitario: product.costo_unitario_default,\n          maquinas: [],\n          nota: 'Costo configurado manualmente (no viene de MAPEX)'\n        };\n      }\n\n      if (product.Cod_maquina) {\n        costConfig[productKey].maquinas.push({\n          cod_maquina: product.Cod_maquina,\n          desc_maquina: product.desc_maquina\n        });\n      }\n    });\n\n    console.log('⚙️ Configuración de costos obtenida:', Object.keys(costConfig).length, 'productos');\n\n    return NextResponse.json({\n      success: true,\n      data: costConfig,\n      timestamp: new Date().toISOString(),\n      nota: 'Costos por defecto: €0. Configure valores reales usando POST'\n    });\n\n  } catch (error) {\n    console.error('❌ Error obteniendo configuración de costos:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Error al obtener configuración de costos',\n      details: error instanceof Error ? error.message : 'Error desconocido',\n      timestamp: new Date().toISOString()\n    }, { status: 500 });\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    console.log('💾 Configurando costo personalizado');\n    const body = await request.json();\n\n    const { cod_producto, costo_unitario, maquina_id } = body;\n\n    if (!cod_producto || costo_unitario === undefined) {\n      return NextResponse.json({\n        success: false,\n        error: 'Faltan parámetros requeridos: cod_producto y costo_unitario',\n        timestamp: new Date().toISOString()\n      }, { status: 400 });\n    }\n\n    // Validar que el producto existe en MAPEX\n    const checkProductSql = `\n      SELECT cod_producto, desc_producto\n      FROM cfg_producto\n      WHERE cod_producto = @cod_producto\n        AND activo = 1\n    `;\n\n    const productExists = await executeQuery(checkProductSql, { cod_producto });\n\n    if (!productExists || productExists.length === 0) {\n      return NextResponse.json({\n        success: false,\n        error: `Producto ${cod_producto} no encontrado en MAPEX`,\n        timestamp: new Date().toISOString()\n      }, { status: 404 });\n    }\n\n    // Aquí se podría guardar en una tabla de configuración\n    // Por ahora, simularemos el guardado\n    console.log('💾 Costo configurado:', {\n      cod_producto,\n      costo_unitario,\n      maquina_id,\n      producto: productExists[0].desc_producto\n    });\n\n    return NextResponse.json({\n      success: true,\n      message: `Costo de €${costo_unitario} configurado para producto ${cod_producto}`,\n      data: {\n        cod_producto,\n        costo_unitario: parseFloat(costo_unitario),\n        maquina_id,\n        producto_descripcion: productExists[0].desc_producto\n      },\n      timestamp: new Date().toISOString()\n    });\n\n  } catch (error) {\n    console.error('❌ Error configurando costo:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Error al configurar costo',\n      details: error instanceof Error ? error.message : 'Error desconocido',\n      timestamp: new Date().toISOString()\n    }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 895, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/src/app/api/analytics/insights/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { executeQuery } from '../../../../../lib/database/connection';\nimport { generarAlertas, analizarParetoCausas } from '../../../../../lib/oee/calculations';\nimport { getAllProductCosts } from '../../scada/costs-config/route';\n\n// Tipos locais para substituir os inexistentes\ninterface DatosProduccion {\n  unidades_ok: number;\n  unidades_nok: number;\n  unidades_rw: number;\n  tiempo_ciclo_ideal_sec?: number;\n  tiempo_planificado_min?: number;\n  velocidad_nominal?: number;\n}\n\ninterface EventoParada {\n  fecha_inicio: Date;\n  fecha_fin?: Date;\n  duracion_minutos: number;\n  tipo_paro: string;\n  descripcion: string;\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    console.log('🧠 Generando insights simplificados');\n\n    // Obtener datos directamente de la API de máquinas que ya funciona\n    const machinesResponse = await fetch('http://localhost:3000/api/scada/machines');\n    const machinesResult = await machinesResponse.json();\n\n    if (!machinesResult.success || !machinesResult.data) {\n      return NextResponse.json({\n        success: false,\n        error: 'No se pudieron obtener datos de las máquinas'\n      }, { status: 500 });\n    }\n\n    const machinesData = machinesResult.data;\n\n    // Insights básicos para cada máquina\n    const machineInsights = machinesData.map((machineData: any) => {\n      const machine = machineData.machine;\n      const totalProduction = (machine.Rt_Unidades_ok || 0) + (machine.Rt_Unidades_nok || 0) + (machine.Rt_Unidades_rw || 0);\n      const efficiency = totalProduction > 0 ?\n        ((machine.Rt_Unidades_ok || 0) / totalProduction) * 100 : 0;\n\n      const alertas = [];\n\n      // Alerta de parada\n      if (machineData.status === 'INACTIVA') {\n        alertas.push({\n          tipo: 'PARADA',\n          severidad: 'ALTA',\n          mensaje: `Máquina ${machine.Cod_maquina} está inactiva`,\n          recomendacion: 'Verificar y resolver la inactividad'\n        });\n      }\n\n      // Alerta de baja eficiencia\n      if (efficiency < 80 && totalProduction > 10) {\n        alertas.push({\n          tipo: 'EFICIENCIA_BAJA',\n          severidad: 'MEDIA',\n          mensaje: `Eficiencia baja en ${machine.Cod_maquina}: ${efficiency.toFixed(1)}%`,\n          recomendacion: 'Revisar parámetros de proceso'\n        });\n      }\n\n      return {\n        machine_id: machine.Cod_maquina,\n        machine_name: machine.desc_maquina,\n        estado: machineData.status,\n        eficiencia_calidad: efficiency,\n        progreso_of: machine.Rt_Unidades_planning > 0 ?\n          ((totalProduction / machine.Rt_Unidades_planning) * 100) : 0,\n        alertas,\n        metricas: {\n          ok: machine.Rt_Unidades_ok || 0,\n          nok: machine.Rt_Unidades_nok || 0,\n          rw: machine.Rt_Unidades_rw || 0,\n          total: totalProduction,\n          velocidad_actual: machineData.velocity?.current || 0,\n          velocidad_nominal: machineData.velocity?.nominal || 0\n        }\n      };\n    });\n\n    // Insights a nivel de planta\n    const activeMachines = machinesData.filter((m: any) => m.status === 'PRODUCIENDO');\n    const inactiveMachines = machinesData.filter((m: any) => m.status === 'INACTIVA');\n    const totalProduction = machinesData.reduce((sum: number, m: any) =>\n      sum + (m.machine?.Rt_Unidades_ok || 0) + (m.machine?.Rt_Unidades_nok || 0) + (m.machine?.Rt_Unidades_rw || 0), 0);\n    const totalOK = machinesData.reduce((sum: number, m: any) => sum + (m.machine?.Rt_Unidades_ok || 0), 0);\n\n    const plantInsights = {\n      eficiencia_planta: {\n        maquinas_activas: activeMachines.length,\n        maquinas_inactivas: inactiveMachines.length,\n        utilizacion: machinesData.length > 0 ? (activeMachines.length / machinesData.length) * 100 : 0,\n        produccion_total: totalProduction,\n        eficiencia_calidad_global: totalProduction > 0 ? (totalOK / totalProduction) * 100 : 0\n      },\n      alertas_criticas: inactiveMachines.length,\n      eficiencia_promedio: activeMachines.length > 0 ?\n        activeMachines.reduce((sum: number, m: any) => {\n          const total = (m.machine?.Rt_Unidades_ok || 0) + (m.machine?.Rt_Unidades_nok || 0) + (m.machine?.Rt_Unidades_rw || 0);\n          return sum + (total > 0 ? ((m.machine?.Rt_Unidades_ok || 0) / total) * 100 : 0);\n        }, 0) / activeMachines.length : 0\n    };\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        timestamp: new Date().toISOString(),\n        turno: 'ACTUAL',\n        insights_maquinas: machineInsights,\n        insights_planta: plantInsights,\n        acciones_recomendadas: inactiveMachines.length > 0 ? [{\n          prioridad: 'CRITICA',\n          categoria: 'INACTIVIDAD',\n          descripcion: `${inactiveMachines.length} máquinas inactivas`,\n          accion: 'Resolver inactividad de máquinas',\n          impacto: 'Alto - afecta producción total'\n        }] : [],\n        resumen: {\n          total_maquinas: machinesData.length,\n          maquinas_activas: activeMachines.length,\n          maquinas_inactivas: inactiveMachines.length,\n          total_alertas: machineInsights.reduce((sum: number, m: any) => sum + m.alertas.length, 0),\n          eficiencia_promedio_planta: plantInsights.eficiencia_promedio\n        }\n      }\n    });\n\n  } catch (error) {\n    console.error('❌ Error generando insights:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Error al generar insights',\n      message: error instanceof Error ? error.message : 'Error desconocido'\n    }, { status: 500 });\n  }\n}\n\nasync function getCurrentMachinesData() {\n  const sql = `\n    SELECT\n      cm.id_maquina,\n      cm.Cod_maquina,\n      cm.desc_maquina,\n      cm.Rt_Cod_of,\n      cm.rt_Cod_producto,\n      cm.Rt_Desc_producto,\n      cm.Rt_Unidades_planning,\n      cm.Rt_Unidades_ok,\n      cm.Rt_Unidades_nok,\n      cm.Rt_Unidades_rw,\n      cm.f_velocidad as velocidad_actual,\n      cm.Rt_Rendimientonominal1 as velocidad_nominal,\n      cm.rt_desc_turno as turno_actual,\n      cm.rt_desc_paro,\n      cm.rt_id_paro,\n      cm.Rt_Desc_operario as operario_actual,\n      -- Estado inferido\n      CASE\n        WHEN cm.rt_id_paro IS NOT NULL AND cm.rt_id_paro > 0 THEN 'PARADA'\n        WHEN cm.Rt_Cod_of IS NOT NULL AND cm.Rt_Cod_of != '--' AND cm.f_velocidad > 0 THEN 'RUN'\n        WHEN cm.Rt_Cod_of IS NOT NULL AND cm.Rt_Cod_of != '--' THEN 'IDLE'\n        ELSE 'STOPPED'\n      END as estado_actual,\n      -- Tiempo ciclo ideal (buscar en configuración de producto)\n      ISNULL(cp.tiempo_ciclo_ideal_sec, 30) as tiempo_ciclo_ideal_sec,\n      -- Metas de OEE\n      ISNULL(cm.meta_disponibilidad, 0.85) as meta_disponibilidad,\n      ISNULL(cm.meta_rendimiento, 0.80) as meta_rendimiento,\n      ISNULL(cm.meta_calidad, 0.95) as meta_calidad,\n      ISNULL(cm.meta_oee, 0.65) as meta_oee\n    FROM cfg_maquina cm\n    LEFT JOIN cfg_producto cp ON cm.rt_Cod_producto = cp.cod_producto\n    WHERE cm.activo = 1\n      AND cm.Cod_maquina != '--'\n    ORDER BY cm.Cod_maquina\n  `;\n\n  return await executeQuery(sql);\n}\n\nasync function generateMachineInsights(machine: any) {\n  // Obtener paradas del turno actual\n  const downtimeEvents = await getMachineDowntimeEvents(machine.id_maquina);\n\n  // Obtener datos de producción del turno\n  const productionData: DatosProduccion = {\n    unidades_ok: machine.Rt_Unidades_ok || 0,\n    unidades_nok: machine.Rt_Unidades_nok || 0,\n    unidades_rw: machine.Rt_Unidades_rw || 0,\n    tiempo_ciclo_ideal_sec: machine.tiempo_ciclo_ideal_sec,\n    tiempo_planificado_min: 480, // 8 horas de turno\n    velocidad_nominal: machine.velocidad_nominal || 100\n  };\n\n  // Obtener costos de productos desde MAPEX\n  const productCosts = await getAllProductCosts();\n  const costoPromedioProducto = Object.keys(productCosts).length > 0\n    ? Object.values(productCosts).reduce((sum, cost) => sum + cost, 0) / Object.keys(productCosts).length\n    : 15.50; // Fallback al valor por defecto\n\n  console.log('💰 Costo promedio para insights:', {\n    totalProductos: Object.keys(productCosts).length,\n    costoPromedio: costoPromedioProducto,\n    nota: 'Usado para calcular impacto económico de mejoras OEE'\n  });\n\n  // Calcular OEE actual (estimación local con datos disponibles)\n  const resultadoOEE = computeOEEFromSnapshot(productionData, downtimeEvents, {\n    velocidad_actual: machine.velocidad_actual || 0,\n    velocidad_nominal: machine.velocidad_nominal || 0,\n    tiempo_planificado_min: 480\n  });\n\n  // Generar alertas\n  const alertas = await generarAlertas(machine.Cod_maquina);\n\n  // Calcular ETA si hay OF activa\n  let eta = null;\n  if (machine.Rt_Cod_of && machine.Rt_Cod_of !== '--' && machine.Rt_Unidades_planning > 0) {\n    const unidades_faltantes = machine.Rt_Unidades_planning - (productionData.unidades_ok + productionData.unidades_nok + productionData.unidades_rw);\n    const velocidad_promedio = machine.velocidad_actual || 0;\n    if (unidades_faltantes > 0 && velocidad_promedio > 0) {\n      const horas_restantes = unidades_faltantes / velocidad_promedio;\n      eta = new Date(Date.now() + horas_restantes * 60 * 60 * 1000);\n    }\n  }\n\n  // Análisis de rendimiento vs histórico\n  const performanceAnalysis = await analyzePerformanceVsHistorical(machine.id_maquina);\n\n  // Detección de patrones anómalos\n  const anomalies = await detectAnomalies(machine);\n\n  return {\n    estado: machine.estado_actual,\n    oee_actual: resultadoOEE,\n    alertas,\n    eta_of: eta,\n    analisis_rendimiento: performanceAnalysis,\n    anomalias: anomalies,\n    recomendaciones: generateMachineRecommendations(machine, resultadoOEE, alertas),\n    metricas_turno: {\n      progreso_of: machine.Rt_Unidades_planning > 0 ?\n        ((productionData.unidades_ok + productionData.unidades_nok + productionData.unidades_rw) / machine.Rt_Unidades_planning) * 100 : 0,\n      eficiencia_calidad: productionData.unidades_ok + productionData.unidades_nok + productionData.unidades_rw > 0 ?\n        (productionData.unidades_ok / (productionData.unidades_ok + productionData.unidades_nok + productionData.unidades_rw)) * 100 : 0,\n      velocidad_vs_nominal: machine.velocidad_nominal > 0 ? (machine.velocidad_actual / machine.velocidad_nominal) * 100 : 0\n    }\n  };\n}\nfunction computeOEEFromSnapshot(prod: DatosProduccion, downtimeEvents: any[], ctx: { velocidad_actual: number; velocidad_nominal: number; tiempo_planificado_min: number; }) {\n  const total = (prod.unidades_ok || 0) + (prod.unidades_nok || 0) + (prod.unidades_rw || 0);\n  const calidad = total > 0 ? (prod.unidades_ok / total) : 0;\n  const disponibilidad = ctx.tiempo_planificado_min > 0 ? Math.max(0, Math.min(1, 1 - (downtimeEvents.reduce((s, e) => s + (e.duracion_sec || 0), 0) / 60) / ctx.tiempo_planificado_min)) : 0;\n  const rendimiento = ctx.velocidad_nominal > 0 ? Math.max(0, Math.min(1, ctx.velocidad_actual / ctx.velocidad_nominal)) : 0;\n  const oee = disponibilidad * rendimiento * calidad;\n  return { oee, rendimiento, disponibilidad, calidad };\n}\n\nasync function getMachineDowntimeEvents(machineId: number): Promise<any[]> {\n  const sql = `\n    SELECT\n      hpp.duracion_minutos * 60 as duracion_sec,\n      hpp.tipo_paro as tipo,\n      hpp.desc_paro as causa,\n      CASE WHEN cp.es_planificado = 1 THEN 1 ELSE 0 END as es_planificada,\n      hpp.fecha_inicio as hora_inicio,\n      hpp.fecha_fin as hora_fin\n    FROM his_prod_paro hpp\n    LEFT JOIN cfg_paro cp ON hpp.id_tipo_paro = cp.id_paro\n    WHERE hpp.id_maquina = ${machineId}\n      AND hpp.fecha_inicio >= CAST(GETDATE() AS DATE) -- Solo hoy\n    ORDER BY hpp.fecha_inicio DESC\n  `;\n\n  const results = await executeQuery(sql);\n\n  return results.map(row => ({\n    duracion_sec: row.duracion_sec || 0,\n    tipo: row.tipo || 'DESCONOCIDO',\n    causa: row.causa,\n    es_planificada: row.es_planificada === 1,\n    hora_inicio: new Date(row.hora_inicio),\n    hora_fin: row.hora_fin ? new Date(row.hora_fin) : undefined\n  }));\n}\n\nasync function analyzePerformanceVsHistorical(machineId: number) {\n  const sql = `\n    SELECT\n      AVG(CAST(oee AS FLOAT)) as oee_promedio_7d,\n      AVG(CAST(disponibilidad AS FLOAT)) as disponibilidad_promedio_7d,\n      AVG(CAST(rendimiento AS FLOAT)) as rendimiento_promedio_7d,\n      AVG(CAST(calidad AS FLOAT)) as calidad_promedio_7d,\n      COUNT(*) as mediciones\n    FROM his_horaOEE\n    WHERE id_maquina = ${machineId}\n      AND fecha >= DATEADD(day, -7, GETDATE())\n  `;\n\n  const historical = await executeQuery(sql);\n  return historical[0] || {};\n}\n\nasync function detectAnomalies(machine: any) {\n  const anomalies = [];\n\n  // Anomalía: Velocidad muy baja comparada con nominal\n  if (machine.velocidad_actual > 0 && machine.velocidad_nominal > 0) {\n    const velocityRatio = machine.velocidad_actual / machine.velocidad_nominal;\n    if (velocityRatio < 0.5) {\n      anomalies.push({\n        tipo: 'VELOCIDAD_ANOMALA',\n        severidad: 'ALTA',\n        descripcion: `Velocidad actual (${machine.velocidad_actual}) muy por debajo de la nominal (${machine.velocidad_nominal})`,\n        valor_actual: machine.velocidad_actual,\n        valor_esperado: machine.velocidad_nominal\n      });\n    }\n  }\n\n  // Anomalía: Alto ratio de NOK\n  const totalProduced = (machine.Rt_Unidades_ok || 0) + (machine.Rt_Unidades_nok || 0) + (machine.Rt_Unidades_rw || 0);\n  if (totalProduced > 10) {\n    const nokRatio = (machine.Rt_Unidades_nok || 0) / totalProduced;\n    if (nokRatio > 0.10) { // Más del 10% NOK\n      anomalies.push({\n        tipo: 'CALIDAD_ANOMALA',\n        severidad: nokRatio > 0.20 ? 'CRITICA' : 'ALTA',\n        descripcion: `Ratio de piezas NOK elevado: ${(nokRatio * 100).toFixed(1)}%`,\n        valor_actual: nokRatio * 100,\n        valor_esperado: 5\n      });\n    }\n  }\n\n  return anomalies;\n}\n\nfunction generateMachineRecommendations(machine: any, oeeResult: any, alertas: any[]) {\n  const recommendations = [];\n\n  // Recomendación basada en disponibilidad\n  if (oeeResult.disponibilidad < 0.80) {\n    recommendations.push({\n      categoria: 'DISPONIBILIDAD',\n      prioridad: 'ALTA',\n      accion: 'Reducir tiempo de paradas no planificadas',\n      detalle: `Tiempo perdido: ${Math.round(oeeResult.tiempo_paradas_no_planificadas_sec / 60)} minutos`,\n      impacto_estimado: `+${((0.85 - oeeResult.disponibilidad) * 8 * 120).toFixed(0)} piezas/turno`\n    });\n  }\n\n  // Recomendación basada en rendimiento\n  if (oeeResult.rendimiento < 0.75) {\n    recommendations.push({\n      categoria: 'RENDIMIENTO',\n      prioridad: 'MEDIA',\n      accion: 'Optimizar velocidad de máquina',\n      detalle: 'Verificar parámetros de proceso y eliminar microparadas',\n      impacto_estimado: `+${((0.80 - oeeResult.rendimiento) * 480 * 2).toFixed(0)} piezas/turno`\n    });\n  }\n\n  // Recomendación basada en calidad\n  if (oeeResult.calidad < 0.90) {\n    recommendations.push({\n      categoria: 'CALIDAD',\n      prioridad: 'ALTA',\n      accion: 'Revisar parámetros de calidad',\n      detalle: 'Calibrar equipos y verificar materias primas',\n      impacto_estimado: `Ahorro: €${((1 - oeeResult.calidad) * 100 * 15.5).toFixed(2)}/turno`\n    });\n  }\n\n  return recommendations;\n}\n\nasync function generatePlantInsights(machinesData: any[]) {\n  const activesMachines = machinesData.filter(m => ['RUN', 'IDLE', 'SETUP'].includes(m.estado_actual));\n  const runningMachines = machinesData.filter(m => m.estado_actual === 'RUN');\n\n  // OEE ponderado de máquinas activas\n  const totalProduction = activesMachines.reduce((sum, m) =>\n    sum + (m.Rt_Unidades_ok || 0) + (m.Rt_Unidades_nok || 0) + (m.Rt_Unidades_rw || 0), 0);\n\n  return {\n    eficiencia_planta: {\n      maquinas_activas: activesMachines.length,\n      maquinas_produciendo: runningMachines.length,\n      utilizacion: machinesData.length > 0 ? (activesMachines.length / machinesData.length) * 100 : 0,\n      produccion_total_turno: totalProduction\n    },\n    cuello_botella: identifyBottleneck(activesMachines),\n    oportunidades_mejora: identifyImprovementOpportunities(machinesData),\n    balance_linea: analyzeLineBalance(activesMachines)\n  };\n}\n\nfunction identifyBottleneck(machines: any[]) {\n  // Identificar máquina con menor velocidad relativa\n  const machinesWithVelocity = machines.filter(m => m.velocidad_actual > 0 && m.velocidad_nominal > 0);\n\n  if (machinesWithVelocity.length === 0) return null;\n\n  const bottleneck = machinesWithVelocity.reduce((min, machine) => {\n    const ratio = machine.velocidad_actual / machine.velocidad_nominal;\n    const minRatio = min.velocidad_actual / min.velocidad_nominal;\n    return ratio < minRatio ? machine : min;\n  });\n\n  return {\n    maquina: bottleneck.Cod_maquina,\n    velocidad_relativa: ((bottleneck.velocidad_actual / bottleneck.velocidad_nominal) * 100).toFixed(1),\n    impacto_estimado: 'Limita capacidad de toda la línea'\n  };\n}\n\nfunction identifyImprovementOpportunities(machines: any[]) {\n  const opportunities = [];\n\n  // Oportunidad: Máquinas paradas con OF pendiente\n  const stoppedWithWork = machines.filter(m =>\n    m.estado_actual === 'PARADA' && m.Rt_Cod_of && m.Rt_Cod_of !== '--'\n  );\n\n  if (stoppedWithWork.length > 0) {\n    opportunities.push({\n      tipo: 'REACTIVACION_RAPIDA',\n      maquinas_afectadas: stoppedWithWork.length,\n      impacto: 'ALTO',\n      descripcion: `${stoppedWithWork.length} máquinas paradas con OF pendiente`,\n      accion: 'Priorizar reanudación de estas máquinas'\n    });\n  }\n\n  // Oportunidad: Desbalance de carga\n  const loadImbalance = calculateLoadImbalance(machines);\n  if (loadImbalance.coefficient > 0.3) {\n    opportunities.push({\n      tipo: 'BALANCE_CARGA',\n      impacto: 'MEDIO',\n      descripcion: 'Distribución desigual de carga entre máquinas',\n      accion: 'Redistribuir órdenes de fabricación',\n      coeficiente_variacion: loadImbalance.coefficient\n    });\n  }\n\n  return opportunities;\n}\n\nfunction calculateLoadImbalance(machines: any[]) {\n  const loads = machines.map(m =>\n    (m.Rt_Unidades_ok || 0) + (m.Rt_Unidades_nok || 0) + (m.Rt_Unidades_rw || 0)\n  );\n\n  const mean = loads.reduce((sum, load) => sum + load, 0) / loads.length;\n  const variance = loads.reduce((sum, load) => sum + Math.pow(load - mean, 2), 0) / loads.length;\n  const stdDev = Math.sqrt(variance);\n\n  return {\n    coefficient: mean > 0 ? stdDev / mean : 0,\n    mean_load: mean,\n    std_deviation: stdDev\n  };\n}\n\nfunction analyzeLineBalance(machines: any[]) {\n  if (machines.length === 0) return null;\n\n  const velocities = machines\n    .filter(m => m.velocidad_actual > 0)\n    .map(m => m.velocidad_actual);\n\n  if (velocities.length === 0) return null;\n\n  const minVelocity = Math.min(...velocities);\n  const maxVelocity = Math.max(...velocities);\n  const avgVelocity = velocities.reduce((sum, v) => sum + v, 0) / velocities.length;\n\n  return {\n    velocidad_minima: minVelocity,\n    velocidad_maxima: maxVelocity,\n    velocidad_promedio: avgVelocity,\n    desbalance_porcentaje: maxVelocity > 0 ? ((maxVelocity - minVelocity) / maxVelocity) * 100 : 0,\n    estado: maxVelocity > 0 && ((maxVelocity - minVelocity) / maxVelocity) < 0.1 ? 'BALANCEADO' : 'DESBALANCEADO'\n  };\n}\n\nasync function generateActionableInsights(machinesData: any[]) {\n  const actions = [];\n\n  // Acciones para máquinas con alertas críticas\n  const criticalMachines = machinesData.filter(m =>\n    m.estado_actual === 'PARADA' ||\n    (m.Rt_Unidades_nok || 0) / ((m.Rt_Unidades_ok || 0) + (m.Rt_Unidades_nok || 0) + 1) > 0.15\n  );\n\n  for (const machine of criticalMachines) {\n    if (machine.estado_actual === 'PARADA') {\n      actions.push({\n        maquina: machine.Cod_maquina,\n        prioridad: 'CRITICA',\n        categoria: 'PARADA_PROLONGADA',\n        accion: 'Investigar y resolver parada inmediatamente',\n        tiempo_estimado: '15-30 min',\n        responsable: 'Técnico de turno'\n      });\n    }\n  }\n\n  return actions;\n}\n\nasync function calculateConsolidatedKPIs(machinesData: any[]) {\n  const activeMachines = machinesData.filter(m => ['RUN', 'IDLE', 'SETUP'].includes(m.estado_actual));\n  const totalProduction = machinesData.reduce((sum, m) =>\n    sum + (m.Rt_Unidades_ok || 0) + (m.Rt_Unidades_nok || 0) + (m.Rt_Unidades_rw || 0), 0);\n  const totalOK = machinesData.reduce((sum, m) => sum + (m.Rt_Unidades_ok || 0), 0);\n\n  return {\n    utilizacion_planta: machinesData.length > 0 ? (activeMachines.length / machinesData.length) * 100 : 0,\n    produccion_total: totalProduction,\n    eficiencia_calidad_global: totalProduction > 0 ? (totalOK / totalProduction) * 100 : 0,\n    maquinas_criticas: machinesData.filter(m => m.estado_actual === 'PARADA').length,\n    velocidad_promedio_planta: activeMachines.length > 0 ?\n      activeMachines.reduce((sum, m) => sum + (m.velocidad_actual || 0), 0) / activeMachines.length : 0\n  };\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAoBO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,QAAQ,GAAG,CAAC;QAEZ,mEAAmE;QACnE,MAAM,mBAAmB,MAAM,MAAM;QACrC,MAAM,iBAAiB,MAAM,iBAAiB,IAAI;QAElD,IAAI,CAAC,eAAe,OAAO,IAAI,CAAC,eAAe,IAAI,EAAE;YACnD,OAAO,yKAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,OAAO;YACT,GAAG;gBAAE,QAAQ;YAAI;QACnB;QAEA,MAAM,eAAe,eAAe,IAAI;QAExC,qCAAqC;QACrC,MAAM,kBAAkB,aAAa,GAAG,CAAC,CAAC;YACxC,MAAM,UAAU,YAAY,OAAO;YACnC,MAAM,kBAAkB,CAAC,QAAQ,cAAc,IAAI,CAAC,IAAI,CAAC,QAAQ,eAAe,IAAI,CAAC,IAAI,CAAC,QAAQ,cAAc,IAAI,CAAC;YACrH,MAAM,aAAa,kBAAkB,IACnC,AAAC,CAAC,QAAQ,cAAc,IAAI,CAAC,IAAI,kBAAmB,MAAM;YAE5D,MAAM,UAAU,EAAE;YAElB,mBAAmB;YACnB,IAAI,YAAY,MAAM,KAAK,YAAY;gBACrC,QAAQ,IAAI,CAAC;oBACX,MAAM;oBACN,WAAW;oBACX,SAAS,CAAC,QAAQ,EAAE,QAAQ,WAAW,CAAC,cAAc,CAAC;oBACvD,eAAe;gBACjB;YACF;YAEA,4BAA4B;YAC5B,IAAI,aAAa,MAAM,kBAAkB,IAAI;gBAC3C,QAAQ,IAAI,CAAC;oBACX,MAAM;oBACN,WAAW;oBACX,SAAS,CAAC,mBAAmB,EAAE,QAAQ,WAAW,CAAC,EAAE,EAAE,WAAW,OAAO,CAAC,GAAG,CAAC,CAAC;oBAC/E,eAAe;gBACjB;YACF;YAEA,OAAO;gBACL,YAAY,QAAQ,WAAW;gBAC/B,cAAc,QAAQ,YAAY;gBAClC,QAAQ,YAAY,MAAM;gBAC1B,oBAAoB;gBACpB,aAAa,QAAQ,oBAAoB,GAAG,IACzC,AAAC,kBAAkB,QAAQ,oBAAoB,GAAI,MAAO;gBAC7D;gBACA,UAAU;oBACR,IAAI,QAAQ,cAAc,IAAI;oBAC9B,KAAK,QAAQ,eAAe,IAAI;oBAChC,IAAI,QAAQ,cAAc,IAAI;oBAC9B,OAAO;oBACP,kBAAkB,YAAY,QAAQ,EAAE,WAAW;oBACnD,mBAAmB,YAAY,QAAQ,EAAE,WAAW;gBACtD;YACF;QACF;QAEA,6BAA6B;QAC7B,MAAM,iBAAiB,aAAa,MAAM,CAAC,CAAC,IAAW,EAAE,MAAM,KAAK;QACpE,MAAM,mBAAmB,aAAa,MAAM,CAAC,CAAC,IAAW,EAAE,MAAM,KAAK;QACtE,MAAM,kBAAkB,aAAa,MAAM,CAAC,CAAC,KAAa,IACxD,MAAM,CAAC,EAAE,OAAO,EAAE,kBAAkB,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,mBAAmB,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,kBAAkB,CAAC,GAAG;QACjH,MAAM,UAAU,aAAa,MAAM,CAAC,CAAC,KAAa,IAAW,MAAM,CAAC,EAAE,OAAO,EAAE,kBAAkB,CAAC,GAAG;QAErG,MAAM,gBAAgB;YACpB,mBAAmB;gBACjB,kBAAkB,eAAe,MAAM;gBACvC,oBAAoB,iBAAiB,MAAM;gBAC3C,aAAa,aAAa,MAAM,GAAG,IAAI,AAAC,eAAe,MAAM,GAAG,aAAa,MAAM,GAAI,MAAM;gBAC7F,kBAAkB;gBAClB,2BAA2B,kBAAkB,IAAI,AAAC,UAAU,kBAAmB,MAAM;YACvF;YACA,kBAAkB,iBAAiB,MAAM;YACzC,qBAAqB,eAAe,MAAM,GAAG,IAC3C,eAAe,MAAM,CAAC,CAAC,KAAa;gBAClC,MAAM,QAAQ,CAAC,EAAE,OAAO,EAAE,kBAAkB,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,mBAAmB,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,kBAAkB,CAAC;gBACpH,OAAO,MAAM,CAAC,QAAQ,IAAI,AAAC,CAAC,EAAE,OAAO,EAAE,kBAAkB,CAAC,IAAI,QAAS,MAAM,CAAC;YAChF,GAAG,KAAK,eAAe,MAAM,GAAG;QACpC;QAEA,OAAO,yKAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,MAAM;gBACJ,WAAW,IAAI,OAAO,WAAW;gBACjC,OAAO;gBACP,mBAAmB;gBACnB,iBAAiB;gBACjB,uBAAuB,iBAAiB,MAAM,GAAG,IAAI;oBAAC;wBACpD,WAAW;wBACX,WAAW;wBACX,aAAa,GAAG,iBAAiB,MAAM,CAAC,mBAAmB,CAAC;wBAC5D,QAAQ;wBACR,SAAS;oBACX;iBAAE,GAAG,EAAE;gBACP,SAAS;oBACP,gBAAgB,aAAa,MAAM;oBACnC,kBAAkB,eAAe,MAAM;oBACvC,oBAAoB,iBAAiB,MAAM;oBAC3C,eAAe,gBAAgB,MAAM,CAAC,CAAC,KAAa,IAAW,MAAM,EAAE,OAAO,CAAC,MAAM,EAAE;oBACvF,4BAA4B,cAAc,mBAAmB;gBAC/D;YACF;QACF;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,yKAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GAAG;YAAE,QAAQ;QAAI;IACnB;AACF;AAEA,eAAe;IACb,MAAM,MAAM,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAqCb,CAAC;IAED,OAAO,MAAM,IAAA,wKAAY,EAAC;AAC5B;AAEA,eAAe,wBAAwB,OAAY;IACjD,mCAAmC;IACnC,MAAM,iBAAiB,MAAM,yBAAyB,QAAQ,UAAU;IAExE,wCAAwC;IACxC,MAAM,iBAAkC;QACtC,aAAa,QAAQ,cAAc,IAAI;QACvC,cAAc,QAAQ,eAAe,IAAI;QACzC,aAAa,QAAQ,cAAc,IAAI;QACvC,wBAAwB,QAAQ,sBAAsB;QACtD,wBAAwB;QACxB,mBAAmB,QAAQ,iBAAiB,IAAI;IAClD;IAEA,0CAA0C;IAC1C,MAAM,eAAe,MAAM,IAAA,uMAAkB;IAC7C,MAAM,wBAAwB,OAAO,IAAI,CAAC,cAAc,MAAM,GAAG,IAC7D,OAAO,MAAM,CAAC,cAAc,MAAM,CAAC,CAAC,KAAK,OAAS,MAAM,MAAM,KAAK,OAAO,IAAI,CAAC,cAAc,MAAM,GACnG,OAAO,gCAAgC;IAE3C,QAAQ,GAAG,CAAC,oCAAoC;QAC9C,gBAAgB,OAAO,IAAI,CAAC,cAAc,MAAM;QAChD,eAAe;QACf,MAAM;IACR;IAEA,+DAA+D;IAC/D,MAAM,eAAe,uBAAuB,gBAAgB,gBAAgB;QAC1E,kBAAkB,QAAQ,gBAAgB,IAAI;QAC9C,mBAAmB,QAAQ,iBAAiB,IAAI;QAChD,wBAAwB;IAC1B;IAEA,kBAAkB;IAClB,MAAM,UAAU,MAAM,IAAA,uKAAc,EAAC,QAAQ,WAAW;IAExD,gCAAgC;IAChC,IAAI,MAAM;IACV,IAAI,QAAQ,SAAS,IAAI,QAAQ,SAAS,KAAK,QAAQ,QAAQ,oBAAoB,GAAG,GAAG;QACvF,MAAM,qBAAqB,QAAQ,oBAAoB,GAAG,CAAC,eAAe,WAAW,GAAG,eAAe,YAAY,GAAG,eAAe,WAAW;QAChJ,MAAM,qBAAqB,QAAQ,gBAAgB,IAAI;QACvD,IAAI,qBAAqB,KAAK,qBAAqB,GAAG;YACpD,MAAM,kBAAkB,qBAAqB;YAC7C,MAAM,IAAI,KAAK,KAAK,GAAG,KAAK,kBAAkB,KAAK,KAAK;QAC1D;IACF;IAEA,uCAAuC;IACvC,MAAM,sBAAsB,MAAM,+BAA+B,QAAQ,UAAU;IAEnF,iCAAiC;IACjC,MAAM,YAAY,MAAM,gBAAgB;IAExC,OAAO;QACL,QAAQ,QAAQ,aAAa;QAC7B,YAAY;QACZ;QACA,QAAQ;QACR,sBAAsB;QACtB,WAAW;QACX,iBAAiB,+BAA+B,SAAS,cAAc;QACvE,gBAAgB;YACd,aAAa,QAAQ,oBAAoB,GAAG,IAC1C,AAAC,CAAC,eAAe,WAAW,GAAG,eAAe,YAAY,GAAG,eAAe,WAAW,IAAI,QAAQ,oBAAoB,GAAI,MAAM;YACnI,oBAAoB,eAAe,WAAW,GAAG,eAAe,YAAY,GAAG,eAAe,WAAW,GAAG,IAC1G,AAAC,eAAe,WAAW,GAAG,CAAC,eAAe,WAAW,GAAG,eAAe,YAAY,GAAG,eAAe,WAAW,IAAK,MAAM;YACjI,sBAAsB,QAAQ,iBAAiB,GAAG,IAAI,AAAC,QAAQ,gBAAgB,GAAG,QAAQ,iBAAiB,GAAI,MAAM;QACvH;IACF;AACF;AACA,SAAS,uBAAuB,IAAqB,EAAE,cAAqB,EAAE,GAA6F;IACzK,MAAM,QAAQ,CAAC,KAAK,WAAW,IAAI,CAAC,IAAI,CAAC,KAAK,YAAY,IAAI,CAAC,IAAI,CAAC,KAAK,WAAW,IAAI,CAAC;IACzF,MAAM,UAAU,QAAQ,IAAK,KAAK,WAAW,GAAG,QAAS;IACzD,MAAM,iBAAiB,IAAI,sBAAsB,GAAG,IAAI,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,IAAI,AAAC,eAAe,MAAM,CAAC,CAAC,GAAG,IAAM,IAAI,CAAC,EAAE,YAAY,IAAI,CAAC,GAAG,KAAK,KAAM,IAAI,sBAAsB,KAAK;IAC1L,MAAM,cAAc,IAAI,iBAAiB,GAAG,IAAI,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,IAAI,gBAAgB,GAAG,IAAI,iBAAiB,KAAK;IACzH,MAAM,MAAM,iBAAiB,cAAc;IAC3C,OAAO;QAAE;QAAK;QAAa;QAAgB;IAAQ;AACrD;AAEA,eAAe,yBAAyB,SAAiB;IACvD,MAAM,MAAM,CAAC;;;;;;;;;;2BAUY,EAAE,UAAU;;;EAGrC,CAAC;IAED,MAAM,UAAU,MAAM,IAAA,wKAAY,EAAC;IAEnC,OAAO,QAAQ,GAAG,CAAC,CAAA,MAAO,CAAC;YACzB,cAAc,IAAI,YAAY,IAAI;YAClC,MAAM,IAAI,IAAI,IAAI;YAClB,OAAO,IAAI,KAAK;YAChB,gBAAgB,IAAI,cAAc,KAAK;YACvC,aAAa,IAAI,KAAK,IAAI,WAAW;YACrC,UAAU,IAAI,QAAQ,GAAG,IAAI,KAAK,IAAI,QAAQ,IAAI;QACpD,CAAC;AACH;AAEA,eAAe,+BAA+B,SAAiB;IAC7D,MAAM,MAAM,CAAC;;;;;;;;uBAQQ,EAAE,UAAU;;EAEjC,CAAC;IAED,MAAM,aAAa,MAAM,IAAA,wKAAY,EAAC;IACtC,OAAO,UAAU,CAAC,EAAE,IAAI,CAAC;AAC3B;AAEA,eAAe,gBAAgB,OAAY;IACzC,MAAM,YAAY,EAAE;IAEpB,qDAAqD;IACrD,IAAI,QAAQ,gBAAgB,GAAG,KAAK,QAAQ,iBAAiB,GAAG,GAAG;QACjE,MAAM,gBAAgB,QAAQ,gBAAgB,GAAG,QAAQ,iBAAiB;QAC1E,IAAI,gBAAgB,KAAK;YACvB,UAAU,IAAI,CAAC;gBACb,MAAM;gBACN,WAAW;gBACX,aAAa,CAAC,kBAAkB,EAAE,QAAQ,gBAAgB,CAAC,gCAAgC,EAAE,QAAQ,iBAAiB,CAAC,CAAC,CAAC;gBACzH,cAAc,QAAQ,gBAAgB;gBACtC,gBAAgB,QAAQ,iBAAiB;YAC3C;QACF;IACF;IAEA,8BAA8B;IAC9B,MAAM,gBAAgB,CAAC,QAAQ,cAAc,IAAI,CAAC,IAAI,CAAC,QAAQ,eAAe,IAAI,CAAC,IAAI,CAAC,QAAQ,cAAc,IAAI,CAAC;IACnH,IAAI,gBAAgB,IAAI;QACtB,MAAM,WAAW,CAAC,QAAQ,eAAe,IAAI,CAAC,IAAI;QAClD,IAAI,WAAW,MAAM;YACnB,UAAU,IAAI,CAAC;gBACb,MAAM;gBACN,WAAW,WAAW,OAAO,YAAY;gBACzC,aAAa,CAAC,6BAA6B,EAAE,CAAC,WAAW,GAAG,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC;gBAC3E,cAAc,WAAW;gBACzB,gBAAgB;YAClB;QACF;IACF;IAEA,OAAO;AACT;AAEA,SAAS,+BAA+B,OAAY,EAAE,SAAc,EAAE,OAAc;IAClF,MAAM,kBAAkB,EAAE;IAE1B,yCAAyC;IACzC,IAAI,UAAU,cAAc,GAAG,MAAM;QACnC,gBAAgB,IAAI,CAAC;YACnB,WAAW;YACX,WAAW;YACX,QAAQ;YACR,SAAS,CAAC,gBAAgB,EAAE,KAAK,KAAK,CAAC,UAAU,kCAAkC,GAAG,IAAI,QAAQ,CAAC;YACnG,kBAAkB,CAAC,CAAC,EAAE,CAAC,CAAC,OAAO,UAAU,cAAc,IAAI,IAAI,GAAG,EAAE,OAAO,CAAC,GAAG,aAAa,CAAC;QAC/F;IACF;IAEA,sCAAsC;IACtC,IAAI,UAAU,WAAW,GAAG,MAAM;QAChC,gBAAgB,IAAI,CAAC;YACnB,WAAW;YACX,WAAW;YACX,QAAQ;YACR,SAAS;YACT,kBAAkB,CAAC,CAAC,EAAE,CAAC,CAAC,OAAO,UAAU,WAAW,IAAI,MAAM,CAAC,EAAE,OAAO,CAAC,GAAG,aAAa,CAAC;QAC5F;IACF;IAEA,kCAAkC;IAClC,IAAI,UAAU,OAAO,GAAG,MAAM;QAC5B,gBAAgB,IAAI,CAAC;YACnB,WAAW;YACX,WAAW;YACX,QAAQ;YACR,SAAS;YACT,kBAAkB,CAAC,SAAS,EAAE,CAAC,CAAC,IAAI,UAAU,OAAO,IAAI,MAAM,IAAI,EAAE,OAAO,CAAC,GAAG,MAAM,CAAC;QACzF;IACF;IAEA,OAAO;AACT;AAEA,eAAe,sBAAsB,YAAmB;IACtD,MAAM,kBAAkB,aAAa,MAAM,CAAC,CAAA,IAAK;YAAC;YAAO;YAAQ;SAAQ,CAAC,QAAQ,CAAC,EAAE,aAAa;IAClG,MAAM,kBAAkB,aAAa,MAAM,CAAC,CAAA,IAAK,EAAE,aAAa,KAAK;IAErE,oCAAoC;IACpC,MAAM,kBAAkB,gBAAgB,MAAM,CAAC,CAAC,KAAK,IACnD,MAAM,CAAC,EAAE,cAAc,IAAI,CAAC,IAAI,CAAC,EAAE,eAAe,IAAI,CAAC,IAAI,CAAC,EAAE,cAAc,IAAI,CAAC,GAAG;IAEtF,OAAO;QACL,mBAAmB;YACjB,kBAAkB,gBAAgB,MAAM;YACxC,sBAAsB,gBAAgB,MAAM;YAC5C,aAAa,aAAa,MAAM,GAAG,IAAI,AAAC,gBAAgB,MAAM,GAAG,aAAa,MAAM,GAAI,MAAM;YAC9F,wBAAwB;QAC1B;QACA,gBAAgB,mBAAmB;QACnC,sBAAsB,iCAAiC;QACvD,eAAe,mBAAmB;IACpC;AACF;AAEA,SAAS,mBAAmB,QAAe;IACzC,mDAAmD;IACnD,MAAM,uBAAuB,SAAS,MAAM,CAAC,CAAA,IAAK,EAAE,gBAAgB,GAAG,KAAK,EAAE,iBAAiB,GAAG;IAElG,IAAI,qBAAqB,MAAM,KAAK,GAAG,OAAO;IAE9C,MAAM,aAAa,qBAAqB,MAAM,CAAC,CAAC,KAAK;QACnD,MAAM,QAAQ,QAAQ,gBAAgB,GAAG,QAAQ,iBAAiB;QAClE,MAAM,WAAW,IAAI,gBAAgB,GAAG,IAAI,iBAAiB;QAC7D,OAAO,QAAQ,WAAW,UAAU;IACtC;IAEA,OAAO;QACL,SAAS,WAAW,WAAW;QAC/B,oBAAoB,CAAC,AAAC,WAAW,gBAAgB,GAAG,WAAW,iBAAiB,GAAI,GAAG,EAAE,OAAO,CAAC;QACjG,kBAAkB;IACpB;AACF;AAEA,SAAS,iCAAiC,QAAe;IACvD,MAAM,gBAAgB,EAAE;IAExB,iDAAiD;IACjD,MAAM,kBAAkB,SAAS,MAAM,CAAC,CAAA,IACtC,EAAE,aAAa,KAAK,YAAY,EAAE,SAAS,IAAI,EAAE,SAAS,KAAK;IAGjE,IAAI,gBAAgB,MAAM,GAAG,GAAG;QAC9B,cAAc,IAAI,CAAC;YACjB,MAAM;YACN,oBAAoB,gBAAgB,MAAM;YAC1C,SAAS;YACT,aAAa,GAAG,gBAAgB,MAAM,CAAC,kCAAkC,CAAC;YAC1E,QAAQ;QACV;IACF;IAEA,mCAAmC;IACnC,MAAM,gBAAgB,uBAAuB;IAC7C,IAAI,cAAc,WAAW,GAAG,KAAK;QACnC,cAAc,IAAI,CAAC;YACjB,MAAM;YACN,SAAS;YACT,aAAa;YACb,QAAQ;YACR,uBAAuB,cAAc,WAAW;QAClD;IACF;IAEA,OAAO;AACT;AAEA,SAAS,uBAAuB,QAAe;IAC7C,MAAM,QAAQ,SAAS,GAAG,CAAC,CAAA,IACzB,CAAC,EAAE,cAAc,IAAI,CAAC,IAAI,CAAC,EAAE,eAAe,IAAI,CAAC,IAAI,CAAC,EAAE,cAAc,IAAI,CAAC;IAG7E,MAAM,OAAO,MAAM,MAAM,CAAC,CAAC,KAAK,OAAS,MAAM,MAAM,KAAK,MAAM,MAAM;IACtE,MAAM,WAAW,MAAM,MAAM,CAAC,CAAC,KAAK,OAAS,MAAM,KAAK,GAAG,CAAC,OAAO,MAAM,IAAI,KAAK,MAAM,MAAM;IAC9F,MAAM,SAAS,KAAK,IAAI,CAAC;IAEzB,OAAO;QACL,aAAa,OAAO,IAAI,SAAS,OAAO;QACxC,WAAW;QACX,eAAe;IACjB;AACF;AAEA,SAAS,mBAAmB,QAAe;IACzC,IAAI,SAAS,MAAM,KAAK,GAAG,OAAO;IAElC,MAAM,aAAa,SAChB,MAAM,CAAC,CAAA,IAAK,EAAE,gBAAgB,GAAG,GACjC,GAAG,CAAC,CAAA,IAAK,EAAE,gBAAgB;IAE9B,IAAI,WAAW,MAAM,KAAK,GAAG,OAAO;IAEpC,MAAM,cAAc,KAAK,GAAG,IAAI;IAChC,MAAM,cAAc,KAAK,GAAG,IAAI;IAChC,MAAM,cAAc,WAAW,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,GAAG,KAAK,WAAW,MAAM;IAEjF,OAAO;QACL,kBAAkB;QAClB,kBAAkB;QAClB,oBAAoB;QACpB,uBAAuB,cAAc,IAAI,AAAC,CAAC,cAAc,WAAW,IAAI,cAAe,MAAM;QAC7F,QAAQ,cAAc,KAAK,AAAC,CAAC,cAAc,WAAW,IAAI,cAAe,MAAM,eAAe;IAChG;AACF;AAEA,eAAe,2BAA2B,YAAmB;IAC3D,MAAM,UAAU,EAAE;IAElB,8CAA8C;IAC9C,MAAM,mBAAmB,aAAa,MAAM,CAAC,CAAA,IAC3C,EAAE,aAAa,KAAK,YACpB,CAAC,EAAE,eAAe,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,cAAc,IAAI,CAAC,IAAI,CAAC,EAAE,eAAe,IAAI,CAAC,IAAI,CAAC,IAAI;IAGxF,KAAK,MAAM,WAAW,iBAAkB;QACtC,IAAI,QAAQ,aAAa,KAAK,UAAU;YACtC,QAAQ,IAAI,CAAC;gBACX,SAAS,QAAQ,WAAW;gBAC5B,WAAW;gBACX,WAAW;gBACX,QAAQ;gBACR,iBAAiB;gBACjB,aAAa;YACf;QACF;IACF;IAEA,OAAO;AACT;AAEA,eAAe,0BAA0B,YAAmB;IAC1D,MAAM,iBAAiB,aAAa,MAAM,CAAC,CAAA,IAAK;YAAC;YAAO;YAAQ;SAAQ,CAAC,QAAQ,CAAC,EAAE,aAAa;IACjG,MAAM,kBAAkB,aAAa,MAAM,CAAC,CAAC,KAAK,IAChD,MAAM,CAAC,EAAE,cAAc,IAAI,CAAC,IAAI,CAAC,EAAE,eAAe,IAAI,CAAC,IAAI,CAAC,EAAE,cAAc,IAAI,CAAC,GAAG;IACtF,MAAM,UAAU,aAAa,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,CAAC,EAAE,cAAc,IAAI,CAAC,GAAG;IAE/E,OAAO;QACL,oBAAoB,aAAa,MAAM,GAAG,IAAI,AAAC,eAAe,MAAM,GAAG,aAAa,MAAM,GAAI,MAAM;QACpG,kBAAkB;QAClB,2BAA2B,kBAAkB,IAAI,AAAC,UAAU,kBAAmB,MAAM;QACrF,mBAAmB,aAAa,MAAM,CAAC,CAAA,IAAK,EAAE,aAAa,KAAK,UAAU,MAAM;QAChF,2BAA2B,eAAe,MAAM,GAAG,IACjD,eAAe,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,CAAC,EAAE,gBAAgB,IAAI,CAAC,GAAG,KAAK,eAAe,MAAM,GAAG;IACpG;AACF","debugId":null}}]
}