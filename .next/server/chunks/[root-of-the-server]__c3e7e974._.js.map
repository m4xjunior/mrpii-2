{"version":3,"sources":["turbopack:///[project]/Downloads/mrpii 2/src/app/api/scada/costs-config/route.ts","turbopack:///[project]/Downloads/mrpii 2/lib/oee/calculations.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { executeQuery } from '../../../../../lib/database/connection';\n\n// Funci√≥n utilitaria para obtener costo de un producto\nexport async function getProductCost(cod_producto: string): Promise<number> {\n  try {\n    // Consulta simple para obtener costo configurado\n    const sql = `\n      SELECT TOP 1\n        cp.cod_producto,\n        0 as costo_default -- Por defecto\n      FROM cfg_producto cp\n      WHERE cp.cod_producto = @cod_producto\n        AND cp.activo = 1\n    `;\n\n    const result = await executeQuery(sql, { cod_producto });\n\n    if (!result || result.length === 0) {\n      console.warn(`‚ö†Ô∏è Producto ${cod_producto} no encontrado, usando costo por defecto ‚Ç¨0`);\n      return 0;\n    }\n\n    // Por ahora, retornar costo por defecto\n    // TODO: Implementar tabla de configuraci√≥n real\n    return 0;\n\n  } catch (error) {\n    console.error(`‚ùå Error obteniendo costo para ${cod_producto}:`, error);\n    return 0; // Fallback a valor por defecto\n  }\n}\n\n// Funci√≥n para obtener todos los costos de productos para c√°lculos mensuales\nexport async function getAllProductCosts(): Promise<{ [key: string]: number }> {\n  try {\n    console.log('üí∞ Obteniendo todos los costos de productos');\n\n    // Consulta para obtener todos los productos activos\n    const sql = `\n      SELECT DISTINCT\n        cp.cod_producto,\n        0 as costo_default -- Por defecto\n      FROM cfg_producto cp\n      WHERE cp.activo = 1\n        AND cp.cod_producto IS NOT NULL\n        AND cp.cod_producto != ''\n        AND cp.cod_producto != '--'\n        AND cp.cod_producto != '{0}'\n    `;\n\n    const products = await executeQuery(sql);\n    const costMap: { [key: string]: number } = {};\n\n    if (products && products.length > 0) {\n      products.forEach((product: any) => {\n        costMap[product.cod_producto] = product.costo_default;\n      });\n    }\n\n    console.log(`üí∞ Costos obtenidos para ${Object.keys(costMap).length} productos`);\n    return costMap;\n\n  } catch (error) {\n    console.error('‚ùå Error obteniendo todos los costos:', error);\n    return {}; // Retornar mapa vac√≠o como fallback\n  }\n}\n\n// API para configurar costos por producto/m√°quina\nexport async function GET(request: NextRequest) {\n  try {\n    console.log('‚öôÔ∏è Obteniendo configuraci√≥n de costos');\n\n    // Obtener productos con sus m√°quinas asociadas\n    const sql = `\n      SELECT DISTINCT\n        cp.cod_producto,\n        cp.desc_producto,\n        cm.Cod_maquina,\n        cm.desc_maquina,\n        0 as costo_unitario_default -- Sin productos = costo cero\n      FROM cfg_producto cp\n      LEFT JOIN cfg_maquina cm ON cp.cod_producto = cm.rt_Cod_producto\n      WHERE cp.activo = 1\n        AND cp.cod_producto IS NOT NULL\n        AND cp.cod_producto != ''\n        AND cp.cod_producto != '--'\n        AND cp.cod_producto != '{0}'\n      ORDER BY cp.cod_producto, cm.Cod_maquina\n    `;\n\n    const products = await executeQuery(sql);\n\n    // Crear estructura de respuesta\n    const costConfig: { [key: string]: any } = {};\n\n    products.forEach((product: any) => {\n      const productKey = product.cod_producto;\n\n      if (!costConfig[productKey]) {\n        costConfig[productKey] = {\n          cod_producto: product.cod_producto,\n          desc_producto: product.desc_producto,\n          costo_unitario: product.costo_unitario_default,\n          maquinas: [],\n          nota: 'Costo configurado manualmente (no viene de MAPEX)'\n        };\n      }\n\n      if (product.Cod_maquina) {\n        costConfig[productKey].maquinas.push({\n          cod_maquina: product.Cod_maquina,\n          desc_maquina: product.desc_maquina\n        });\n      }\n    });\n\n    console.log('‚öôÔ∏è Configuraci√≥n de costos obtenida:', Object.keys(costConfig).length, 'productos');\n\n    return NextResponse.json({\n      success: true,\n      data: costConfig,\n      timestamp: new Date().toISOString(),\n      nota: 'Costos por defecto: ‚Ç¨0. Configure valores reales usando POST'\n    });\n\n  } catch (error) {\n    console.error('‚ùå Error obteniendo configuraci√≥n de costos:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Error al obtener configuraci√≥n de costos',\n      details: error instanceof Error ? error.message : 'Error desconocido',\n      timestamp: new Date().toISOString()\n    }, { status: 500 });\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    console.log('üíæ Configurando costo personalizado');\n    const body = await request.json();\n\n    const { cod_producto, costo_unitario, maquina_id } = body;\n\n    if (!cod_producto || costo_unitario === undefined) {\n      return NextResponse.json({\n        success: false,\n        error: 'Faltan par√°metros requeridos: cod_producto y costo_unitario',\n        timestamp: new Date().toISOString()\n      }, { status: 400 });\n    }\n\n    // Validar que el producto existe en MAPEX\n    const checkProductSql = `\n      SELECT cod_producto, desc_producto\n      FROM cfg_producto\n      WHERE cod_producto = @cod_producto\n        AND activo = 1\n    `;\n\n    const productExists = await executeQuery(checkProductSql, { cod_producto });\n\n    if (!productExists || productExists.length === 0) {\n      return NextResponse.json({\n        success: false,\n        error: `Producto ${cod_producto} no encontrado en MAPEX`,\n        timestamp: new Date().toISOString()\n      }, { status: 404 });\n    }\n\n    // Aqu√≠ se podr√≠a guardar en una tabla de configuraci√≥n\n    // Por ahora, simularemos el guardado\n    console.log('üíæ Costo configurado:', {\n      cod_producto,\n      costo_unitario,\n      maquina_id,\n      producto: productExists[0].desc_producto\n    });\n\n    return NextResponse.json({\n      success: true,\n      message: `Costo de ‚Ç¨${costo_unitario} configurado para producto ${cod_producto}`,\n      data: {\n        cod_producto,\n        costo_unitario: parseFloat(costo_unitario),\n        maquina_id,\n        producto_descripcion: productExists[0].desc_producto\n      },\n      timestamp: new Date().toISOString()\n    });\n\n  } catch (error) {\n    console.error('‚ùå Error configurando costo:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Error al configurar costo',\n      details: error instanceof Error ? error.message : 'Error desconocido',\n      timestamp: new Date().toISOString()\n    }, { status: 500 });\n  }\n}\n","import { executeQuery } from '../database/connection';\n\nexport interface OEECalculation {\n  oee: number;\n  rendimiento: number;\n  disponibilidad: number;\n  calidad: number;\n}\n\nexport interface ProductionData {\n  total_ok: number;\n  total_nok: number;\n  total_rw: number;\n  tiempo_produccion_segundos: number;\n  fecha_inicio_real: string | null;\n  fecha_fin_real: string | null;\n}\n\n/**\n * Calcula OEE usando a fun√ß√£o F_his_ct() do MAPEX (simulada)\n * Esta fun√ß√£o simula o comportamento da fun√ß√£o F_his_ct('WORKCENTER','','OF',...) do MAPEX\n */\nexport async function calculateOEEForOF(\n  machineCode: string,\n  codOF: string,\n  daysBack: number = 10\n): Promise<OEECalculation | null> {\n  try {\n    // Simular a fun√ß√£o F_his_ct() do MAPEX - calcular OEE baseado em dados hist√≥ricos\n    const sql = `\n      SELECT\n        -- Disponibilidad: tiempo disponible vs tiempo total\n        CASE\n          WHEN SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) -\n               ISNULL(SUM(CASE WHEN hp.id_actividad = 3 THEN CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT) ELSE 0 END), 0)\n              ) * 100.0 /\n              SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)), 2\n            )\n          ELSE 0\n        END as disponibilidad,\n\n        -- Rendimiento: unidades producidas vs velocidad nominal\n        CASE\n          WHEN cm.Rt_Rendimientonominal1 > 0 AND SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(hp.unidades_ok + hp.unidades_nok) * 3600.0) /\n              (cm.Rt_Rendimientonominal1 * (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) / 3600.0)), 2\n            )\n          ELSE 0\n        END as rendimiento,\n\n        -- Calidad: unidades OK vs total producidas\n        CASE\n          WHEN SUM(hp.unidades_ok + hp.unidades_nok) > 0 THEN\n            ROUND((SUM(hp.unidades_ok) * 100.0) / SUM(hp.unidades_ok + hp.unidades_nok), 2)\n          ELSE 0\n        END as calidad\n\n      FROM cfg_maquina cm\n      LEFT JOIN his_fase hf ON cm.rt_id_his_fase = hf.id_his_fase\n      LEFT JOIN his_prod hp ON hf.id_his_fase = hp.id_his_fase\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND cm.Rt_Cod_of = '${codOF}'\n      AND hp.fecha_fin >= DATEADD(DAY, -${daysBack}, GETDATE())\n      AND hp.id_actividad = 2 -- Producci√≥n\n      GROUP BY cm.Rt_Rendimientonominal1 -- Agrupar para agregar correctamente\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    const row = result[0];\n    const disponibilidad = Math.max(0, Math.min(100, row.disponibilidad || 0));\n    const rendimiento = Math.max(0, Math.min(100, row.rendimiento || 0));\n    const calidad = Math.max(0, Math.min(100, row.calidad || 0));\n\n    // OEE = Disponibilidad √ó Rendimiento √ó Calidad\n    const oee = Math.round((disponibilidad * rendimiento * calidad) / 10000);\n\n    return {\n      oee,\n      rendimiento,\n      disponibilidad,\n      calidad\n    };\n  } catch (error) {\n    console.error('‚ùå Erro ao calcular OEE para OF:', error);\n    return null;\n  }\n}\n\n/**\n * Calcula OEE por turno usando simula√ß√£o da fun√ß√£o F_his_ct('WORKCENTER','DAY','TURNO',...)\n */\nexport async function calculateOEEForTurno(\n  machineCode: string,\n  diaProductivo: string\n): Promise<OEECalculation | null> {\n  try {\n    const sql = `\n      SELECT\n        -- Disponibilidad del turno\n        CASE\n          WHEN SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) -\n               ISNULL(SUM(CASE WHEN hp.id_actividad = 3 THEN CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT) ELSE 0 END), 0)\n              ) * 100.0 /\n              SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)), 2\n            )\n          ELSE 0\n        END as disponibilidad,\n\n        -- Rendimiento del turno\n        CASE\n          WHEN cm.Rt_Rendimientonominal1 > 0 AND SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(hp.unidades_ok + hp.unidades_nok) * 3600.0) /\n              (cm.Rt_Rendimientonominal1 * (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) / 3600.0)), 2\n            )\n          ELSE 0\n        END as rendimiento,\n\n        -- Calidad del turno\n        CASE\n          WHEN SUM(hp.unidades_ok + hp.unidades_nok) > 0 THEN\n            ROUND((SUM(hp.unidades_ok) * 100.0) / SUM(hp.unidades_ok + hp.unidades_nok), 2)\n          ELSE 0\n        END as calidad\n\n      FROM cfg_maquina cm\n      LEFT JOIN his_fase hf ON cm.rt_id_his_fase = hf.id_his_fase\n      LEFT JOIN his_prod hp ON hf.id_his_fase = hp.id_his_fase\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND CONVERT(VARCHAR(10), cm.rt_dia_productivo, 111) = '${diaProductivo}'\n      AND hp.id_actividad = 2 -- Producci√≥n\n      GROUP BY cm.Rt_Rendimientonominal1 -- Agrupar para agregar correctamente\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    const row = result[0];\n    const disponibilidad = Math.max(0, Math.min(100, row.disponibilidad || 0));\n    const rendimiento = Math.max(0, Math.min(100, row.rendimiento || 0));\n    const calidad = Math.max(0, Math.min(100, row.calidad || 0));\n\n    const oee = Math.round((disponibilidad * rendimiento * calidad) / 10000);\n\n    return {\n      oee,\n      rendimiento,\n      disponibilidad,\n      calidad\n    };\n  } catch (error) {\n    console.error('‚ùå Erro ao calcular OEE para turno:', error);\n    return null;\n  }\n}\n\n/**\n * Obt√©m dados de produ√ß√£o detalhados para uma OF\n */\nexport async function getProductionDataForOF(\n  machineCode: string,\n  codOF: string\n): Promise<ProductionData | null> {\n  try {\n    const sql = `\n      SELECT\n        SUM(hp.unidades_ok) as total_ok,\n        SUM(hp.unidades_nok) as total_nok,\n        SUM(hp.unidades_repro) as total_rw,\n        SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) as tiempo_produccion_segundos,\n        MIN(hp.fecha_ini) as fecha_inicio_real,\n        MAX(hp.fecha_fin) as fecha_fin_real\n      FROM his_prod hp\n      INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase\n      INNER JOIN his_of ho ON hf.id_his_of = ho.id_his_of\n      WHERE ho.cod_of = '${codOF}'\n      AND hp.id_actividad = 2 -- Producci√≥n\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    return result[0] as ProductionData;\n  } catch (error) {\n    console.error('‚ùå Erro ao obter dados de produ√ß√£o:', error);\n    return null;\n  }\n}\n\n/**\n * Calcula tempo restante para completar uma OF\n */\nexport function calculateRemainingTime(\n  remainingPieces: number,\n  velocity: number\n): string {\n  if (velocity > 0 && remainingPieces > 0) {\n    const remainingHours = remainingPieces / velocity;\n    if (remainingHours >= 24) {\n      return `${Math.round(remainingHours / 24)}d`;\n    } else {\n      return `${remainingHours.toFixed(1)}h`;\n    }\n  }\n  return 'N/A';\n}\n\n/**\n * Calcula percentual de avan√ßo de uma OF\n */\nexport function calculateProgress(\n  totalProduced: number,\n  plannedUnits: number\n): number {\n  if (plannedUnits > 0) {\n    return Math.round((totalProduced / plannedUnits) * 100);\n  }\n  return 0;\n}\n\n/**\n * Calcula OEE (fun√ß√£o de compatibilidade)\n */\nexport async function calcularOEE(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<OEECalculation | null> {\n  return calculateOEEForOF(machineCode, '', 30); // Simplificado\n}\n\n/**\n * Calcula OEE ponderado (fun√ß√£o de compatibilidade)\n */\nexport async function calcularOEEPonderado(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<number> {\n  const oee = await calculateOEEForOF(machineCode, '', 30);\n  return oee?.oee || 0;\n}\n\n/**\n * Gera alertas baseado em dados OEE (fun√ß√£o de compatibilidade)\n */\nexport async function generarAlertas(\n  machineCode: string\n): Promise<any[]> {\n  try {\n    const oee = await calculateOEEForOF(machineCode, '', 1);\n    const alerts = [];\n\n    if (oee) {\n      if (oee.oee < 60) {\n        alerts.push({\n          type: 'danger',\n          message: 'OEE cr√≠tico: abaixo de 60%',\n          value: oee.oee\n        });\n      } else if (oee.oee < 75) {\n        alerts.push({\n          type: 'warning',\n          message: 'OEE baixo: abaixo de 75%',\n          value: oee.oee\n        });\n      }\n\n      if (oee.disponibilidad < 80) {\n        alerts.push({\n          type: 'warning',\n          message: 'Disponibilidade baixa',\n          value: oee.disponibilidad\n        });\n      }\n\n      if (oee.calidad < 95) {\n        alerts.push({\n          type: 'warning',\n          message: 'Qualidade baixa',\n          value: oee.calidad\n        });\n      }\n    }\n\n    return alerts;\n  } catch (error) {\n    console.error('Erro ao gerar alertas:', error);\n    return [];\n  }\n}\n\n/**\n * An√°lise Pareto de causas de paros\n */\nexport async function analizarParetoCausas(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<any[]> {\n  try {\n    const sql = `\n      SELECT\n        cp.desc_paro as causa,\n        SUM(DATEDIFF(MINUTE, hpp.fecha_ini, hpp.fecha_fin)) as tiempo_total_minutos,\n        COUNT(*) as cantidad_paros\n      FROM his_prod hp\n      INNER JOIN his_prod_paro hpp ON hp.id_his_prod = hpp.id_his_prod\n      INNER JOIN cfg_paro cp ON hpp.id_paro = cp.id_paro\n      INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND hpp.fecha_ini >= '${startDate.toISOString()}'\n      AND hpp.fecha_ini <= '${endDate.toISOString()}'\n      GROUP BY cp.desc_paro\n      ORDER BY tiempo_total_minutos DESC\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    // Calcular percentual cumulativo (Pareto 80/20)\n    const totalTiempo = result.reduce((sum, item) => sum + (item.tiempo_total_minutos || 0), 0);\n    let tiempoAcumulado = 0;\n\n    return result.map(item => {\n      tiempoAcumulado += item.tiempo_total_minutos || 0;\n      return {\n        causa: item.causa || 'Sin causa',\n        tiempo_total_minutos: item.tiempo_total_minutos || 0,\n        cantidad_paros: item.cantidad_paros || 0,\n        porcentaje: totalTiempo > 0 ? Math.round((item.tiempo_total_minutos / totalTiempo) * 100) : 0,\n        porcentaje_acumulado: totalTiempo > 0 ? Math.round((tiempoAcumulado / totalTiempo) * 100) : 0\n      };\n    });\n  } catch (error) {\n    console.error('Erro ao analisar Pareto de causas:', error);\n    return [];\n  }\n}"],"names":[],"mappings":"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"}