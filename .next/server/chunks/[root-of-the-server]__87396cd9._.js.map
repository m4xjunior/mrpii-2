{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/lib/database/connection.ts"],"sourcesContent":["import { Connection, Request, TYPES } from 'tedious';\n\n// Configuraciones para múltiples bases de datos como en el PHP original\nconst baseConfig: any = {\n  server: process.env.DB_SERVER || '10.0.0.45',\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: process.env.DB_USER || 'sa',\n      password: process.env.DB_PASSWORD || 'Mapexdd2017',\n    },\n  },\n  options: {\n    port: parseInt(process.env.DB_PORT || '1433'),\n    encrypt: false,\n    trustServerCertificate: true,\n    connectTimeout: 30000,\n    requestTimeout: 30000,\n    enableArithAbort: true,\n  },\n};\n\n// Configuraciones específicas para cada base de datos\nconst mapexConfig: any = {\n  ...baseConfig,\n  options: {\n    ...baseConfig.options,\n    database: process.env.DB_NAME || 'mapexbp_Test',\n  },\n};\n\nconst sageConfig: any = {\n  ...baseConfig,\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: 'sa',\n      password: 'admin000',\n    },\n  },\n  options: {\n    ...baseConfig.options,\n    database: 'SAGE',\n  },\n};\n\nconst whalesConfig: any = {\n  ...baseConfig,\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: 'sa',\n      password: '87cc88bb89.',\n    },\n  },\n  options: {\n    ...baseConfig.options,\n    database: 'WHALES',\n  },\n};\n\n// Função para criar uma nova conexão para cada query (evita conflitos de estado)\nexport async function getDbConnection(database: 'mapex' | 'sage' | 'whales' = 'mapex'): Promise<Connection> {\n  let config: any;\n  switch (database) {\n    case 'mapex':\n      config = mapexConfig;\n      break;\n    case 'sage':\n      config = sageConfig;\n      break;\n    case 'whales':\n      config = whalesConfig;\n      break;\n    default:\n      config = mapexConfig;\n  }\n\n  const connection = new Connection(config);\n\n  return new Promise((resolve, reject) => {\n    connection.on('connect', (err) => {\n      if (err) {\n        console.error(`❌ Erro ao conectar à base ${database.toUpperCase()}:`, err);\n        reject(err);\n      } else {\n        console.log(`✅ Nova conexão criada para ${database.toUpperCase()}`);\n        resolve(connection);\n      }\n    });\n\n    connection.on('error', (err) => {\n      console.error(`❌ Erro na conexão ${database.toUpperCase()}:`, err);\n      reject(err);\n    });\n\n    // Não definir on('end') aqui pois vamos fechar manualmente\n\n    connection.connect();\n  });\n}\n\nexport async function executeQuery<T = any>(\n  sql: string,\n  parameters?: { [key: string]: any },\n  database: 'mapex' | 'sage' | 'whales' = 'mapex'\n): Promise<T[]> {\n  const conn = await getDbConnection(database);\n\n  return new Promise((resolve, reject) => {\n    const results: T[] = [];\n\n    const request = new Request(sql, (err) => {\n      // Sempre fechar a conexão após completar a query\n      try {\n        conn.close();\n      } catch (closeErr) {\n        console.warn('⚠️ Erro ao fechar conexão:', closeErr);\n      }\n\n      if (err) {\n        console.error(`❌ Erro na query ${database.toUpperCase()}:`, err);\n        console.error('SQL:', sql.substring(0, 200) + '...');\n        reject(err);\n      } else {\n        resolve(results);\n      }\n    });\n\n    // Adicionar parâmetros se fornecidos\n    if (parameters) {\n      Object.entries(parameters).forEach(([key, value]) => {\n        let type: any = TYPES.NVarChar;\n        if (typeof value === 'number') {\n          type = Number.isInteger(value) ? TYPES.Int : TYPES.Float;\n        } else if (typeof value === 'boolean') {\n          type = TYPES.Bit;\n        } else if (value instanceof Date) {\n          type = TYPES.DateTime;\n        }\n        request.addParameter(key, type, value);\n      });\n    }\n\n    request.on('row', (columns: any) => {\n      const row: any = {};\n      columns.forEach((column: any) => {\n        row[column.metadata.colName] = column.value;\n      });\n      results.push(row);\n    });\n\n    try {\n      conn.execSql(request);\n    } catch (execErr) {\n      // Se houver erro na execução, fechar conexão e rejeitar\n      try {\n        conn.close();\n      } catch (closeErr) {\n        console.warn('⚠️ Erro ao fechar conexão após falha:', closeErr);\n      }\n      reject(execErr);\n    }\n  });\n}\n\nexport async function closeDbConnection(database?: 'mapex' | 'sage' | 'whales'): Promise<void> {\n  // Como agora criamos uma nova conexão para cada query e fechamos automaticamente,\n  // esta função é mantida por compatibilidade mas não faz mais sentido\n  console.log('ℹ️ Conexões agora são gerenciadas automaticamente por query');\n}\n\n// Função para testar conectividade\nexport async function testConnections(): Promise<{ [key: string]: boolean }> {\n  const results: { [key: string]: boolean } = {};\n\n  for (const db of ['mapex', 'sage', 'whales'] as const) {\n    try {\n      await executeQuery('SELECT 1 as test', undefined, db);\n      results[db] = true;\n      console.log(`✅ Teste de conectividade ${db.toUpperCase()}: OK`);\n    } catch (error) {\n      results[db] = false;\n      console.error(`❌ Teste de conectividade ${db.toUpperCase()}: FALHOU`, error);\n    }\n  }\n\n  return results;\n}"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA,wEAAwE;AACxE,MAAM,aAAkB;IACtB,QAAQ,QAAQ,GAAG,CAAC,SAAS,IAAI;IACjC,gBAAgB;QACd,MAAM;QACN,SAAS;YACP,UAAU,QAAQ,GAAG,CAAC,OAAO,IAAI;YACjC,UAAU,QAAQ,GAAG,CAAC,WAAW,IAAI;QACvC;IACF;IACA,SAAS;QACP,MAAM,SAAS,QAAQ,GAAG,CAAC,OAAO,IAAI;QACtC,SAAS;QACT,wBAAwB;QACxB,gBAAgB;QAChB,gBAAgB;QAChB,kBAAkB;IACpB;AACF;AAEA,sDAAsD;AACtD,MAAM,cAAmB;IACvB,GAAG,UAAU;IACb,SAAS;QACP,GAAG,WAAW,OAAO;QACrB,UAAU,QAAQ,GAAG,CAAC,OAAO,IAAI;IACnC;AACF;AAEA,MAAM,aAAkB;IACtB,GAAG,UAAU;IACb,gBAAgB;QACd,MAAM;QACN,SAAS;YACP,UAAU;YACV,UAAU;QACZ;IACF;IACA,SAAS;QACP,GAAG,WAAW,OAAO;QACrB,UAAU;IACZ;AACF;AAEA,MAAM,eAAoB;IACxB,GAAG,UAAU;IACb,gBAAgB;QACd,MAAM;QACN,SAAS;YACP,UAAU;YACV,UAAU;QACZ;IACF;IACA,SAAS;QACP,GAAG,WAAW,OAAO;QACrB,UAAU;IACZ;AACF;AAGO,eAAe,gBAAgB,WAAwC,OAAO;IACnF,IAAI;IACJ,OAAQ;QACN,KAAK;YACH,SAAS;YACT;QACF,KAAK;YACH,SAAS;YACT;QACF,KAAK;YACH,SAAS;YACT;QACF;YACE,SAAS;IACb;IAEA,MAAM,aAAa,IAAI,kLAAU,CAAC;IAElC,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,WAAW,EAAE,CAAC,WAAW,CAAC;YACxB,IAAI,KAAK;gBACP,QAAQ,KAAK,CAAC,CAAC,0BAA0B,EAAE,SAAS,WAAW,GAAG,CAAC,CAAC,EAAE;gBACtE,OAAO;YACT,OAAO;gBACL,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,SAAS,WAAW,IAAI;gBAClE,QAAQ;YACV;QACF;QAEA,WAAW,EAAE,CAAC,SAAS,CAAC;YACtB,QAAQ,KAAK,CAAC,CAAC,kBAAkB,EAAE,SAAS,WAAW,GAAG,CAAC,CAAC,EAAE;YAC9D,OAAO;QACT;QAEA,2DAA2D;QAE3D,WAAW,OAAO;IACpB;AACF;AAEO,eAAe,aACpB,GAAW,EACX,UAAmC,EACnC,WAAwC,OAAO;IAE/C,MAAM,OAAO,MAAM,gBAAgB;IAEnC,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,MAAM,UAAe,EAAE;QAEvB,MAAM,UAAU,IAAI,+KAAO,CAAC,KAAK,CAAC;YAChC,iDAAiD;YACjD,IAAI;gBACF,KAAK,KAAK;YACZ,EAAE,OAAO,UAAU;gBACjB,QAAQ,IAAI,CAAC,8BAA8B;YAC7C;YAEA,IAAI,KAAK;gBACP,QAAQ,KAAK,CAAC,CAAC,gBAAgB,EAAE,SAAS,WAAW,GAAG,CAAC,CAAC,EAAE;gBAC5D,QAAQ,KAAK,CAAC,QAAQ,IAAI,SAAS,CAAC,GAAG,OAAO;gBAC9C,OAAO;YACT,OAAO;gBACL,QAAQ;YACV;QACF;QAEA,qCAAqC;QACrC,IAAI,YAAY;YACd,OAAO,OAAO,CAAC,YAAY,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM;gBAC9C,IAAI,OAAY,6KAAK,CAAC,QAAQ;gBAC9B,IAAI,OAAO,UAAU,UAAU;oBAC7B,OAAO,OAAO,SAAS,CAAC,SAAS,6KAAK,CAAC,GAAG,GAAG,6KAAK,CAAC,KAAK;gBAC1D,OAAO,IAAI,OAAO,UAAU,WAAW;oBACrC,OAAO,6KAAK,CAAC,GAAG;gBAClB,OAAO,IAAI,iBAAiB,MAAM;oBAChC,OAAO,6KAAK,CAAC,QAAQ;gBACvB;gBACA,QAAQ,YAAY,CAAC,KAAK,MAAM;YAClC;QACF;QAEA,QAAQ,EAAE,CAAC,OAAO,CAAC;YACjB,MAAM,MAAW,CAAC;YAClB,QAAQ,OAAO,CAAC,CAAC;gBACf,GAAG,CAAC,OAAO,QAAQ,CAAC,OAAO,CAAC,GAAG,OAAO,KAAK;YAC7C;YACA,QAAQ,IAAI,CAAC;QACf;QAEA,IAAI;YACF,KAAK,OAAO,CAAC;QACf,EAAE,OAAO,SAAS;YAChB,wDAAwD;YACxD,IAAI;gBACF,KAAK,KAAK;YACZ,EAAE,OAAO,UAAU;gBACjB,QAAQ,IAAI,CAAC,yCAAyC;YACxD;YACA,OAAO;QACT;IACF;AACF;AAEO,eAAe,kBAAkB,QAAsC;IAC5E,kFAAkF;IAClF,qEAAqE;IACrE,QAAQ,GAAG,CAAC;AACd;AAGO,eAAe;IACpB,MAAM,UAAsC,CAAC;IAE7C,KAAK,MAAM,MAAM;QAAC;QAAS;QAAQ;KAAS,CAAW;QACrD,IAAI;YACF,MAAM,aAAa,oBAAoB,WAAW;YAClD,OAAO,CAAC,GAAG,GAAG;YACd,QAAQ,GAAG,CAAC,CAAC,yBAAyB,EAAE,GAAG,WAAW,GAAG,IAAI,CAAC;QAChE,EAAE,OAAO,OAAO;YACd,OAAO,CAAC,GAAG,GAAG;YACd,QAAQ,KAAK,CAAC,CAAC,yBAAyB,EAAE,GAAG,WAAW,GAAG,QAAQ,CAAC,EAAE;QACxE;IACF;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/src/app/api/scada/costs-config/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { executeQuery } from '../../../../../lib/database/connection';\n\n// Función utilitaria para obtener costo de un producto\nexport async function getProductCost(cod_producto: string): Promise<number> {\n  try {\n    // Consulta simple para obtener costo configurado\n    const sql = `\n      SELECT TOP 1\n        cp.cod_producto,\n        0 as costo_default -- Por defecto\n      FROM cfg_producto cp\n      WHERE cp.cod_producto = @cod_producto\n        AND cp.activo = 1\n    `;\n\n    const result = await executeQuery(sql, { cod_producto });\n\n    if (!result || result.length === 0) {\n      console.warn(`⚠️ Producto ${cod_producto} no encontrado, usando costo por defecto €0`);\n      return 0;\n    }\n\n    // Por ahora, retornar costo por defecto\n    // TODO: Implementar tabla de configuración real\n    return 0;\n\n  } catch (error) {\n    console.error(`❌ Error obteniendo costo para ${cod_producto}:`, error);\n    console.warn('⚠️ Usando costo por defecto debido a error de conexión');\n    return 0; // Fallback a valor por defecto\n  }\n}\n\n// Función para obtener todos los costos de productos para cálculos mensuales\nexport async function getAllProductCosts(): Promise<{ [key: string]: number }> {\n  try {\n    console.log('💰 Obteniendo todos los costos de productos');\n\n    // Consulta para obtener todos los productos activos\n    const sql = `\n      SELECT DISTINCT\n        cp.cod_producto,\n        0 as costo_default -- Por defecto\n      FROM cfg_producto cp\n      WHERE cp.activo = 1\n        AND cp.cod_producto IS NOT NULL\n        AND cp.cod_producto != ''\n        AND cp.cod_producto != '--'\n        AND cp.cod_producto != '{0}'\n    `;\n\n    const products = await executeQuery(sql);\n    const costMap: { [key: string]: number } = {};\n\n    if (products && products.length > 0) {\n      products.forEach((product: any) => {\n        costMap[product.cod_producto] = product.costo_default;\n      });\n    }\n\n    console.log(`💰 Costos obtenidos para ${Object.keys(costMap).length} productos`);\n    return costMap;\n\n  } catch (error) {\n    console.error('❌ Error obteniendo todos los costos:', error);\n    return {}; // Retornar mapa vacío como fallback\n  }\n}\n\n// API para configurar costos por producto/máquina\nexport async function GET(request: NextRequest) {\n  try {\n    console.log('⚙️ Obteniendo configuración de costos');\n\n    // Obtener productos con sus máquinas asociadas\n    const sql = `\n      SELECT DISTINCT\n        cp.cod_producto,\n        cp.desc_producto,\n        cm.Cod_maquina,\n        cm.desc_maquina,\n        0 as costo_unitario_default -- Sin productos = costo cero\n      FROM cfg_producto cp\n      LEFT JOIN cfg_maquina cm ON cp.cod_producto = cm.rt_Cod_producto\n      WHERE cp.activo = 1\n        AND cp.cod_producto IS NOT NULL\n        AND cp.cod_producto != ''\n        AND cp.cod_producto != '--'\n        AND cp.cod_producto != '{0}'\n      ORDER BY cp.cod_producto, cm.Cod_maquina\n    `;\n\n    const products = await executeQuery(sql);\n\n    // Crear estructura de respuesta\n    const costConfig: { [key: string]: any } = {};\n\n    products.forEach((product: any) => {\n      const productKey = product.cod_producto;\n\n      if (!costConfig[productKey]) {\n        costConfig[productKey] = {\n          cod_producto: product.cod_producto,\n          desc_producto: product.desc_producto,\n          costo_unitario: product.costo_unitario_default,\n          maquinas: [],\n          nota: 'Costo configurado manualmente (no viene de MAPEX)'\n        };\n      }\n\n      if (product.Cod_maquina) {\n        costConfig[productKey].maquinas.push({\n          cod_maquina: product.Cod_maquina,\n          desc_maquina: product.desc_maquina\n        });\n      }\n    });\n\n    console.log('⚙️ Configuración de costos obtenida:', Object.keys(costConfig).length, 'productos');\n\n    return NextResponse.json({\n      success: true,\n      data: costConfig,\n      timestamp: new Date().toISOString(),\n      nota: 'Costos por defecto: €0. Configure valores reales usando POST'\n    });\n\n  } catch (error) {\n    console.error('❌ Error obteniendo configuración de costos:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Error al obtener configuración de costos',\n      details: error instanceof Error ? error.message : 'Error desconocido',\n      timestamp: new Date().toISOString()\n    }, { status: 500 });\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    console.log('💾 Configurando costo personalizado');\n    const body = await request.json();\n\n    const { cod_producto, costo_unitario, maquina_id } = body;\n\n    if (!cod_producto || costo_unitario === undefined) {\n      return NextResponse.json({\n        success: false,\n        error: 'Faltan parámetros requeridos: cod_producto y costo_unitario',\n        timestamp: new Date().toISOString()\n      }, { status: 400 });\n    }\n\n    // Validar que el producto existe en MAPEX\n    const checkProductSql = `\n      SELECT cod_producto, desc_producto\n      FROM cfg_producto\n      WHERE cod_producto = @cod_producto\n        AND activo = 1\n    `;\n\n    const productExists = await executeQuery(checkProductSql, { cod_producto });\n\n    if (!productExists || productExists.length === 0) {\n      return NextResponse.json({\n        success: false,\n        error: `Producto ${cod_producto} no encontrado en MAPEX`,\n        timestamp: new Date().toISOString()\n      }, { status: 404 });\n    }\n\n    // Aquí se podría guardar en una tabla de configuración\n    // Por ahora, simularemos el guardado\n    console.log('💾 Costo configurado:', {\n      cod_producto,\n      costo_unitario,\n      maquina_id,\n      producto: productExists[0].desc_producto\n    });\n\n    return NextResponse.json({\n      success: true,\n      message: `Costo de €${costo_unitario} configurado para producto ${cod_producto}`,\n      data: {\n        cod_producto,\n        costo_unitario: parseFloat(costo_unitario),\n        maquina_id,\n        producto_descripcion: productExists[0].desc_producto\n      },\n      timestamp: new Date().toISOString()\n    });\n\n  } catch (error) {\n    console.error('❌ Error configurando costo:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Error al configurar costo',\n      details: error instanceof Error ? error.message : 'Error desconocido',\n      timestamp: new Date().toISOString()\n    }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/src/app/api/analytics/historical/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { executeQuery } from '../../../../../lib/database/connection';\nimport { calcularOEE, calcularOEEPonderado, generarAlertas, analizarParetoCausas } from '../../../../../lib/oee/calculations';\nimport { getAllProductCosts } from '../../scada/costs-config/route';\n\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const machineId = searchParams.get('machineId') || null;\n    const days = parseInt(searchParams.get('days') || '30');\n\n    console.log(`📊 Buscando datos históricos - Máquina: ${machineId}, Días: ${days}`);\n\n    // Obtener costos de productos desde MAPEX\n    const productCosts = await getAllProductCosts();\n    const costoPromedioNok = Object.keys(productCosts).length > 0\n      ? Object.values(productCosts).reduce((sum, cost) => sum + cost, 0) / Object.keys(productCosts).length\n      : 15.50; // Fallback al valor por defecto\n\n    console.log('💰 Costo promedio para cálculos históricos:', {\n      totalProductos: Object.keys(productCosts).length,\n      costoPromedio: costoPromedioNok,\n      nota: 'Usado para calcular costos de scrap en consultas SQL'\n    });\n\n    // Intentar obtener datos reales de MAPEX\n    let productionData = [];\n    let downtimeData = [];\n\n    try {\n      // Query muy simple para testear conectividad\n      const testSql = `SELECT TOP 1 'OK' as status, GETDATE() as fecha`;\n      await executeQuery(testSql, undefined, 'mapex');\n      console.log('✅ Conexión MAPEX OK');\n\n      // Query simplificada para producción\n      const productionSql = `\n        SELECT TOP 10\n          CONVERT(VARCHAR(10), hp.fecha, 120) as fecha,\n          cm.Cod_maquina,\n          COUNT(*) as registros\n        FROM his_prod hp\n        INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n        WHERE hp.fecha >= DATEADD(day, -${days}, GETDATE())\n          AND cm.activo = 1\n          ${machineId ? `AND cm.Cod_maquina = '${machineId}'` : ''}\n        GROUP BY CONVERT(VARCHAR(10), hp.fecha, 120), cm.Cod_maquina\n        ORDER BY fecha DESC\n      `;\n\n      productionData = await executeQuery(productionSql, undefined, 'mapex');\n      console.log(`📊 Datos de producción: ${productionData.length} registros`);\n\n    } catch (prodError) {\n      const prodMsg = prodError instanceof Error ? prodError.message : String(prodError);\n      console.warn('⚠️ Error al buscar datos de producción:', prodMsg);\n      console.warn('⚠️ Usando datos simulados para producción');\n      productionData = getSimulatedProductionData(days, machineId);\n    }\n\n    try {\n      // Query simplificada para paros\n      const downtimeSql = `\n        SELECT TOP 10\n          CONVERT(VARCHAR(10), hpp.fecha_inicio, 120) as fecha,\n          cm.Cod_maquina,\n          COUNT(*) as num_paros\n        FROM his_prod_paro hpp\n        INNER JOIN his_prod hp ON hpp.id_his_prod = hp.id_his_prod\n        INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n        WHERE hpp.fecha_inicio >= DATEADD(day, -${days}, GETDATE())\n          AND cm.activo = 1\n          ${machineId ? `AND cm.Cod_maquina = '${machineId}'` : ''}\n        GROUP BY CONVERT(VARCHAR(10), hpp.fecha_inicio, 120), cm.Cod_maquina\n        ORDER BY fecha DESC\n      `;\n\n      downtimeData = await executeQuery(downtimeSql, undefined, 'mapex');\n      console.log(`📊 Datos de paros: ${downtimeData.length} registros`);\n\n    } catch (downError) {\n      const downMsg = downError instanceof Error ? downError.message : String(downError);\n      console.warn('⚠️ Error al buscar datos de paros:', downMsg);\n      console.warn('⚠️ Usando datos simulados para paros');\n      downtimeData = getSimulatedDowntimeData(days, machineId);\n    }\n\n    // Insights básicos\n    const insights = [];\n    if (productionData.length > 0) {\n      const totalRegistros = productionData.reduce((sum, item) => sum + (item.registros || 0), 0);\n\n      insights.push({\n        tipo: 'PRODUCCION_RESUMEN',\n        mensaje: `Total registros de producción: ${totalRegistros} en ${productionData.length} días`,\n        prioridad: 'INFO'\n      });\n    }\n\n    if (downtimeData.length > 0) {\n      const totalParos = downtimeData.reduce((sum, item) => sum + (item.num_paros || 0), 0);\n      insights.push({\n        tipo: 'PAROS_RESUMEN',\n        mensaje: `Total paros registrados: ${totalParos} en ${downtimeData.length} días`,\n        prioridad: 'INFO'\n      });\n    }\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        production: productionData,\n        downtime: downtimeData,\n        insights: insights,\n        filters: {\n          machineId,\n          days,\n          dateRange: {\n            from: new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString().split('T')[0],\n            to: new Date().toISOString().split('T')[0]\n          }\n        }\n      },\n      timestamp: new Date().toISOString()\n    });\n\n  } catch (error) {\n    console.error('❌ Error en datos históricos:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Error al obtener datos históricos',\n      message: error instanceof Error ? error.message : 'Error desconocido'\n    }, { status: 500 });\n  }\n}\n\n// Función para generar datos simulados de producción\nfunction getSimulatedProductionData(days: number, machineId: string | null) {\n  const data: any[] = [];\n  const machines = ['DOBL01', 'DOBL02', 'SOLD01', 'SOLD02', 'TROQ01', 'TERM01'];\n  const targetMachines = machineId ? [machineId] : machines;\n\n  for (let i = days; i >= 0; i--) {\n    const date = new Date();\n    date.setDate(date.getDate() - i);\n\n    targetMachines.forEach(machine => {\n      data.push({\n        fecha: date.toISOString().split('T')[0],\n        Cod_maquina: machine,\n        registros: Math.floor(Math.random() * 50) + 10 // 10-60 registros por día\n      });\n    });\n  }\n\n  return data;\n}\n\n// Función para generar datos simulados de paros\nfunction getSimulatedDowntimeData(days: number, machineId: string | null) {\n  const data: any[] = [];\n  const machines = ['DOBL01', 'DOBL02', 'SOLD01', 'SOLD02', 'TROQ01', 'TERM01'];\n  const targetMachines = machineId ? [machineId] : machines;\n\n  for (let i = days; i >= 0; i--) {\n    const date = new Date();\n    date.setDate(date.getDate() - i);\n\n    targetMachines.forEach(machine => {\n      // Solo algunos días tienen paros\n      if (Math.random() < 0.3) {\n        data.push({\n          fecha: date.toISOString().split('T')[0],\n          Cod_maquina: machine,\n          num_paros: Math.floor(Math.random() * 3) + 1 // 1-3 paros por día\n        });\n      }\n    });\n  }\n\n  return data;\n}\n\nasync function getHistoricalProductionData(machineId: string | null, days: number, aggregation: string) {\n  const machineFilter = machineId ? `AND cm.Cod_maquina = '${machineId}'` : '';\n\n  let dateFormat = '';\n  let groupBy = '';\n\n  switch (aggregation) {\n    case 'minute':\n      dateFormat = \"FORMAT(hp.fecha, 'yyyy-MM-dd HH:mm')\";\n      groupBy = \"FORMAT(hp.fecha, 'yyyy-MM-dd HH:mm'), cm.Cod_maquina\";\n      break;\n    case 'hour':\n      dateFormat = \"FORMAT(hp.fecha, 'yyyy-MM-dd HH')\";\n      groupBy = \"FORMAT(hp.fecha, 'yyyy-MM-dd HH'), cm.Cod_maquina\";\n      break;\n    case 'day':\n      dateFormat = \"FORMAT(hp.fecha, 'yyyy-MM-dd')\";\n      groupBy = \"FORMAT(hp.fecha, 'yyyy-MM-dd'), cm.Cod_maquina\";\n      break;\n  }\n\n  const sql = `\n    SELECT\n      ${dateFormat} as periodo,\n      cm.Cod_maquina,\n      cm.desc_maquina,\n      SUM(hp.unidades_ok) as piezas_ok,\n      SUM(hp.unidades_nok) as piezas_nok,\n      SUM(hp.unidades_rw) as piezas_rw,\n      SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_rw) as total_pieces,\n      AVG(hp.velocidad_real) as velocidad_promedio,\n      AVG(hp.tiempo_ciclo_real) as tiempo_ciclo_promedio,\n      COUNT(*) as registros,\n      STRING_AGG(hp.turno, ',') as turnos,\n      STRING_AGG(DISTINCT hp.operario, ',') as operarios\n    FROM his_prod hp\n    INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n    WHERE hp.fecha >= DATEADD(day, -${days}, GETDATE())\n      AND cm.activo = 1\n      ${machineFilter}\n    GROUP BY ${groupBy}\n    ORDER BY periodo DESC, cm.Cod_maquina\n  `;\n\n  try {\n    return await executeQuery(sql, undefined, 'mapex');\n  } catch (error) {\n    console.warn('⚠️ Error al obtener datos históricos - retornando datos vacíos');\n    return [];\n  }\n}\n\nasync function getHistoricalDowntimeData(machineId: string | null, days: number) {\n  const machineFilter = machineId ? `AND cm.Cod_maquina = '${machineId}'` : '';\n\n  const sql = `\n    SELECT\n      FORMAT(hpp.fecha_inicio, 'yyyy-MM-dd HH:mm') as fecha_inicio,\n      FORMAT(hpp.fecha_fin, 'yyyy-MM-dd HH:mm') as fecha_fin,\n      cm.Cod_maquina,\n      cm.desc_maquina,\n      hpp.duracion_minutos,\n      CAST(hpp.duracion_minutos AS FLOAT) / 60 as duracion_horas,\n      hpp.tipo_paro,\n      hpp.desc_paro as causa,\n      hpp.operario,\n      CASE WHEN cpp.es_planificado = 1 THEN 1 ELSE 0 END as es_planificada,\n      cpp.costo_hora_estimado,\n      (CAST(hpp.duracion_minutos AS FLOAT) / 60) * ISNULL(cpp.costo_hora_estimado, 150) as costo_estimado_euros\n    FROM his_prod_paro hpp\n    INNER JOIN cfg_maquina cm ON hpp.id_maquina = cm.id_maquina\n    LEFT JOIN cfg_paro cpp ON hpp.id_tipo_paro = cpp.id_paro\n    WHERE hpp.fecha_inicio >= DATEADD(day, -${days}, GETDATE())\n      AND cm.activo = 1\n      ${machineFilter}\n    ORDER BY hpp.fecha_inicio DESC\n  `;\n\n  try {\n    return await executeQuery(sql, undefined, 'mapex');\n  } catch (error) {\n    console.warn('⚠️ Error al obtener datos históricos - retornando datos vacíos');\n    return [];\n  }\n}\n\nasync function calculateHistoricalOEE(machineId: string | null, days: number, aggregation: string) {\n  const machineFilter = machineId ? `AND cm.Cod_maquina = '${machineId}'` : '';\n\n  let dateFormat = '';\n  switch (aggregation) {\n    case 'hour':\n      dateFormat = \"FORMAT(fecha, 'yyyy-MM-dd HH')\";\n      break;\n    case 'day':\n      dateFormat = \"FORMAT(fecha, 'yyyy-MM-dd')\";\n      break;\n    default:\n      dateFormat = \"FORMAT(fecha, 'yyyy-MM-dd HH')\";\n  }\n\n  const sql = `\n    SELECT\n      ${dateFormat} as periodo,\n      cm.Cod_maquina,\n      cm.desc_maquina,\n      AVG(CAST(disponibilidad AS FLOAT)) as disponibilidad,\n      AVG(CAST(rendimiento AS FLOAT)) as rendimiento,\n      AVG(CAST(calidad AS FLOAT)) as calidad,\n      AVG(CAST(oee AS FLOAT)) as oee,\n      AVG(tiempo_planificado_min) as tiempo_planificado_promedio,\n      SUM(piezas_producidas) as total_piezas,\n      COUNT(*) as mediciones\n    FROM his_horaOEE hoee\n    INNER JOIN cfg_maquina cm ON hoee.id_maquina = cm.id_maquina\n    WHERE hoee.fecha >= DATEADD(day, -${days}, GETDATE())\n      AND cm.activo = 1\n      ${machineFilter}\n    GROUP BY ${dateFormat}, cm.Cod_maquina, cm.desc_maquina\n    ORDER BY periodo DESC, cm.Cod_maquina\n  `;\n\n  try {\n    return await executeQuery(sql, undefined, 'mapex');\n  } catch (error) {\n    console.warn('⚠️ Error al obtener datos históricos - retornando datos vacíos');\n    return [];\n  }\n}\n\nasync function getOperatorProductivityMetrics(machineId: string | null, days: number) {\n  const machineFilter = machineId ? `AND cm.Cod_maquina = '${machineId}'` : '';\n\n  const sql = `\n    SELECT\n      hp.operario,\n      cm.Cod_maquina,\n      COUNT(DISTINCT CAST(hp.fecha AS DATE)) as dias_trabajados,\n      SUM(hp.unidades_ok) as total_piezas_ok,\n      SUM(hp.unidades_nok) as total_piezas_nok,\n      SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_rw) as total_piezas,\n      AVG(CAST(hp.unidades_ok AS FLOAT) / NULLIF(hp.unidades_ok + hp.unidades_nok + hp.unidades_rw, 0)) as eficiencia_promedio,\n      SUM(hp.tiempo_trabajado_min) as total_minutos_trabajados,\n      CASE\n        WHEN SUM(hp.tiempo_trabajado_min) > 0\n        THEN (SUM(hp.unidades_ok) * 60.0) / SUM(hp.tiempo_trabajado_min)\n        ELSE 0\n      END as piezas_por_hora,\n      -- Calcular costo de ineficiencia\n      SUM(hp.unidades_nok) * 15.5 as costo_scrap_euros, -- Costo promedio fallback (no disponible aquí)\n      -- Ranking por productividad\n      RANK() OVER (ORDER BY\n        CASE\n          WHEN SUM(hp.tiempo_trabajado_min) > 0\n          THEN (SUM(hp.unidades_ok) * 60.0) / SUM(hp.tiempo_trabajado_min)\n          ELSE 0\n        END DESC\n      ) as ranking_productividad\n    FROM his_prod hp\n    INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n    WHERE hp.fecha >= DATEADD(day, -${days}, GETDATE())\n      AND cm.activo = 1\n      AND hp.operario IS NOT NULL\n      AND hp.operario != ''\n      ${machineFilter}\n    GROUP BY hp.operario, cm.Cod_maquina\n    HAVING SUM(hp.tiempo_trabajado_min) >= 60 -- Al menos 1 hora trabajada\n    ORDER BY piezas_por_hora DESC\n  `;\n\n  try {\n    return await executeQuery(sql, undefined, 'mapex');\n  } catch (error) {\n    console.warn('⚠️ Error al obtener datos históricos - retornando datos vacíos');\n    return [];\n  }\n}\n\nasync function getCostAnalysis(machineId: string | null, days: number) {\n  const machineFilter = machineId ? `AND cm.Cod_maquina = '${machineId}'` : '';\n\n  const sql = `\n    SELECT\n      cm.Cod_maquina,\n      cm.desc_maquina,\n      -- Costos de paradas\n      SUM(CASE WHEN cpp.es_planificado = 0 THEN (CAST(hpp.duracion_minutos AS FLOAT) / 60) * ISNULL(cpp.costo_hora_estimado, 150) ELSE 0 END) as costo_paradas_no_planificadas_euros,\n      SUM(CASE WHEN cpp.es_planificado = 1 THEN (CAST(hpp.duracion_minutos AS FLOAT) / 60) * ISNULL(cpp.costo_hora_estimado, 75) ELSE 0 END) as costo_paradas_planificadas_euros,\n      -- Costos de scrap\n      SUM(hp.unidades_nok) * 15.5 as costo_scrap_euros,\n      -- Tiempo perdido\n      SUM(CASE WHEN cpp.es_planificado = 0 THEN hpp.duracion_minutos ELSE 0 END) as minutos_perdidos_no_planificados,\n      -- Cálculo de oportunidad perdida (velocidad nominal vs real)\n      SUM(\n        CASE\n          WHEN hp.velocidad_nominal > hp.velocidad_real AND hp.tiempo_trabajado_min > 0\n          THEN ((hp.velocidad_nominal - hp.velocidad_real) / hp.velocidad_nominal) * hp.tiempo_trabajado_min * 2.5 -- €2.5 por minuto de oportunidad\n          ELSE 0\n        END\n      ) as costo_oportunidad_perdida_euros,\n      -- Total de costos\n      SUM(CASE WHEN cpp.es_planificado = 0 THEN (CAST(hpp.duracion_minutos AS FLOAT) / 60) * ISNULL(cpp.costo_hora_estimado, 150) ELSE 0 END) +\n      SUM(hp.unidades_nok) * 15.5 +\n      SUM(\n        CASE\n          WHEN hp.velocidad_nominal > hp.velocidad_real AND hp.tiempo_trabajado_min > 0\n          THEN ((hp.velocidad_nominal - hp.velocidad_real) / hp.velocidad_nominal) * hp.tiempo_trabajado_min * 2.5\n          ELSE 0\n        END\n      ) as costo_total_perdidas_euros\n    FROM cfg_maquina cm\n    LEFT JOIN his_prod_paro hpp ON cm.id_maquina = hpp.id_maquina\n      AND hpp.fecha_inicio >= DATEADD(day, -${days}, GETDATE())\n    LEFT JOIN cfg_paro cpp ON hpp.id_tipo_paro = cpp.id_paro\n    LEFT JOIN his_prod hp ON cm.id_maquina = hp.id_maquina\n      AND hp.fecha >= DATEADD(day, -${days}, GETDATE())\n    WHERE cm.activo = 1\n      ${machineFilter}\n    GROUP BY cm.Cod_maquina, cm.desc_maquina\n    ORDER BY costo_total_perdidas_euros DESC\n  `;\n\n  try {\n    return await executeQuery(sql, undefined, 'mapex');\n  } catch (error) {\n    console.warn('⚠️ Error al obtener datos históricos - retornando datos vacíos');\n    return [];\n  }\n}\n\nasync function analyzeTrends(historicalData: any[]) {\n  if (historicalData.length < 2) return { trend: 'INSUFICIENTES_DATOS' };\n\n  // Análisis de tendencias simples\n  const recent = historicalData.slice(0, Math.floor(historicalData.length / 2));\n  const older = historicalData.slice(Math.floor(historicalData.length / 2));\n\n  const recentAvgProduction = recent.reduce((sum, item) => sum + item.total_pieces, 0) / recent.length;\n  const olderAvgProduction = older.reduce((sum, item) => sum + item.total_pieces, 0) / older.length;\n\n  const productionTrend = recentAvgProduction > olderAvgProduction ? 'MEJORANDO' :\n                         recentAvgProduction < olderAvgProduction ? 'EMPEORANDO' : 'ESTABLE';\n\n  return {\n    production_trend: productionTrend,\n    recent_avg_production: recentAvgProduction,\n    older_avg_production: olderAvgProduction,\n    improvement_percentage: ((recentAvgProduction - olderAvgProduction) / olderAvgProduction * 100).toFixed(2)\n  };\n}\n\nasync function generateInsights(machineId: string | null, oeeHistory: any[], downtimeData: any[]) {\n  const insights = [];\n\n  // Análisis simplificado - apenas insights básicos\n  if (downtimeData.length > 0) {\n    const totalDowntime = downtimeData.reduce((sum, item) => sum + (item.duracion_horas || 0), 0);\n    insights.push({\n      tipo: 'RESUMEN_PAROS',\n      prioridad: 'MEDIA',\n      mensaje: `Total de tiempo en paros: ${totalDowntime.toFixed(1)} horas`,\n      accion_recomendada: 'Revisar eficiencia operacional',\n      datos: { totalDowntime, numParos: downtimeData.length }\n    });\n  }\n\n  if (oeeHistory.length > 0) {\n    const avgOEE = oeeHistory.reduce((sum, item) => sum + (item.oee || 0), 0) / oeeHistory.length;\n    insights.push({\n      tipo: 'RESUMEN_OEE',\n      prioridad: avgOEE < 75 ? 'ALTA' : 'MEDIA',\n      mensaje: `OEE promedio: ${avgOEE.toFixed(1)}%`,\n      accion_recomendada: avgOEE < 75 ? 'Mejorar disponibilidad, rendimiento y calidad' : 'Mantener el buen rendimiento',\n      datos: { avgOEE, numRegistros: oeeHistory.length }\n    });\n  }\n\n  return insights;\n}"],"names":[],"mappings":"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","debugId":null}}]
}