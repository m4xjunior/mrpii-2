{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/lib/database/connection.ts"],"sourcesContent":["import { Connection, Request, TYPES } from 'tedious';\n\n// Configuraciones para múltiples bases de datos como en el PHP original\nconst baseConfig: any = {\n  server: process.env.DB_SERVER || '10.0.0.45',\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: process.env.DB_USER || 'sa',\n      password: process.env.DB_PASSWORD || 'Mapexdd2017',\n    },\n  },\n  options: {\n    port: parseInt(process.env.DB_PORT || '1433'),\n    encrypt: false,\n    trustServerCertificate: true,\n    connectTimeout: 30000,\n    requestTimeout: 30000,\n    enableArithAbort: true,\n  },\n};\n\n// Configuraciones específicas para cada base de datos\nconst mapexConfig: any = {\n  ...baseConfig,\n  options: {\n    ...baseConfig.options,\n    database: process.env.DB_NAME || 'mapexbp_Test',\n  },\n};\n\nconst sageConfig: any = {\n  ...baseConfig,\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: 'sa',\n      password: 'admin000',\n    },\n  },\n  options: {\n    ...baseConfig.options,\n    database: 'SAGE',\n  },\n};\n\nconst whalesConfig: any = {\n  ...baseConfig,\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: 'sa',\n      password: '87cc88bb89.',\n    },\n  },\n  options: {\n    ...baseConfig.options,\n    database: 'WHALES',\n  },\n};\n\n// Função para criar uma nova conexão para cada query (evita conflitos de estado)\nexport async function getDbConnection(database: 'mapex' | 'sage' | 'whales' = 'mapex'): Promise<Connection> {\n  let config: any;\n  switch (database) {\n    case 'mapex':\n      config = mapexConfig;\n      break;\n    case 'sage':\n      config = sageConfig;\n      break;\n    case 'whales':\n      config = whalesConfig;\n      break;\n    default:\n      config = mapexConfig;\n  }\n\n  const connection = new Connection(config);\n\n  return new Promise((resolve, reject) => {\n    connection.on('connect', (err) => {\n      if (err) {\n        console.error(`❌ Erro ao conectar à base ${database.toUpperCase()}:`, err);\n        reject(err);\n      } else {\n        console.log(`✅ Nova conexão criada para ${database.toUpperCase()}`);\n        resolve(connection);\n      }\n    });\n\n    connection.on('error', (err) => {\n      console.error(`❌ Erro na conexão ${database.toUpperCase()}:`, err);\n      reject(err);\n    });\n\n    // Não definir on('end') aqui pois vamos fechar manualmente\n\n    connection.connect();\n  });\n}\n\nexport async function executeQuery<T = any>(\n  sql: string,\n  parameters?: { [key: string]: any },\n  database: 'mapex' | 'sage' | 'whales' = 'mapex'\n): Promise<T[]> {\n  const conn = await getDbConnection(database);\n\n  return new Promise((resolve, reject) => {\n    const results: T[] = [];\n\n    const request = new Request(sql, (err) => {\n      // Sempre fechar a conexão após completar a query\n      try {\n        conn.close();\n      } catch (closeErr) {\n        console.warn('⚠️ Erro ao fechar conexão:', closeErr);\n      }\n\n      if (err) {\n        console.error(`❌ Erro na query ${database.toUpperCase()}:`, err);\n        console.error('SQL:', sql.substring(0, 200) + '...');\n        reject(err);\n      } else {\n        resolve(results);\n      }\n    });\n\n    // Adicionar parâmetros se fornecidos\n    if (parameters) {\n      Object.entries(parameters).forEach(([key, value]) => {\n        let type: any = TYPES.NVarChar;\n        if (typeof value === 'number') {\n          type = Number.isInteger(value) ? TYPES.Int : TYPES.Float;\n        } else if (typeof value === 'boolean') {\n          type = TYPES.Bit;\n        } else if (value instanceof Date) {\n          type = TYPES.DateTime;\n        }\n        request.addParameter(key, type, value);\n      });\n    }\n\n    request.on('row', (columns: any) => {\n      const row: any = {};\n      columns.forEach((column: any) => {\n        row[column.metadata.colName] = column.value;\n      });\n      results.push(row);\n    });\n\n    try {\n      conn.execSql(request);\n    } catch (execErr) {\n      // Se houver erro na execução, fechar conexão e rejeitar\n      try {\n        conn.close();\n      } catch (closeErr) {\n        console.warn('⚠️ Erro ao fechar conexão após falha:', closeErr);\n      }\n      reject(execErr);\n    }\n  });\n}\n\nexport async function closeDbConnection(database?: 'mapex' | 'sage' | 'whales'): Promise<void> {\n  // Como agora criamos uma nova conexão para cada query e fechamos automaticamente,\n  // esta função é mantida por compatibilidade mas não faz mais sentido\n  console.log('ℹ️ Conexões agora são gerenciadas automaticamente por query');\n}\n\n// Função para testar conectividade\nexport async function testConnections(): Promise<{ [key: string]: boolean }> {\n  const results: { [key: string]: boolean } = {};\n\n  for (const db of ['mapex', 'sage', 'whales'] as const) {\n    try {\n      await executeQuery('SELECT 1 as test', undefined, db);\n      results[db] = true;\n      console.log(`✅ Teste de conectividade ${db.toUpperCase()}: OK`);\n    } catch (error) {\n      results[db] = false;\n      console.error(`❌ Teste de conectividade ${db.toUpperCase()}: FALHOU`, error);\n    }\n  }\n\n  return results;\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/src/app/api/scada/costs-config/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { executeQuery } from '../../../../../lib/database/connection';\n\n// Función utilitaria para obtener costo de un producto\nexport async function getProductCost(cod_producto: string): Promise<number> {\n  try {\n    // Consulta simple para obtener costo configurado\n    const sql = `\n      SELECT TOP 1\n        cp.cod_producto,\n        0 as costo_default -- Por defecto\n      FROM cfg_producto cp\n      WHERE cp.cod_producto = @cod_producto\n        AND cp.activo = 1\n    `;\n\n    const result = await executeQuery(sql, { cod_producto });\n\n    if (!result || result.length === 0) {\n      console.warn(`⚠️ Producto ${cod_producto} no encontrado, usando costo por defecto €0`);\n      return 0;\n    }\n\n    // Por ahora, retornar costo por defecto\n    // TODO: Implementar tabla de configuración real\n    return 0;\n\n  } catch (error) {\n    console.error(`❌ Error obteniendo costo para ${cod_producto}:`, error);\n    console.warn('⚠️ Usando costo por defecto debido a error de conexión');\n    return 0; // Fallback a valor por defecto\n  }\n}\n\n// Función para obtener todos los costos de productos para cálculos mensuales\nexport async function getAllProductCosts(): Promise<{ [key: string]: number }> {\n  try {\n    console.log('💰 Obteniendo todos los costos de productos');\n\n    // Consulta para obtener todos los productos activos\n    const sql = `\n      SELECT DISTINCT\n        cp.cod_producto,\n        0 as costo_default -- Por defecto\n      FROM cfg_producto cp\n      WHERE cp.activo = 1\n        AND cp.cod_producto IS NOT NULL\n        AND cp.cod_producto != ''\n        AND cp.cod_producto != '--'\n        AND cp.cod_producto != '{0}'\n    `;\n\n    const products = await executeQuery(sql);\n    const costMap: { [key: string]: number } = {};\n\n    if (products && products.length > 0) {\n      products.forEach((product: any) => {\n        costMap[product.cod_producto] = product.costo_default;\n      });\n    }\n\n    console.log(`💰 Costos obtenidos para ${Object.keys(costMap).length} productos`);\n    return costMap;\n\n  } catch (error) {\n    console.error('❌ Error obteniendo todos los costos:', error);\n    return {}; // Retornar mapa vacío como fallback\n  }\n}\n\n// API para configurar costos por producto/máquina\nexport async function GET(request: NextRequest) {\n  try {\n    console.log('⚙️ Obteniendo configuración de costos');\n\n    // Obtener productos con sus máquinas asociadas\n    const sql = `\n      SELECT DISTINCT\n        cp.cod_producto,\n        cp.desc_producto,\n        cm.Cod_maquina,\n        cm.desc_maquina,\n        0 as costo_unitario_default -- Sin productos = costo cero\n      FROM cfg_producto cp\n      LEFT JOIN cfg_maquina cm ON cp.cod_producto = cm.rt_Cod_producto\n      WHERE cp.activo = 1\n        AND cp.cod_producto IS NOT NULL\n        AND cp.cod_producto != ''\n        AND cp.cod_producto != '--'\n        AND cp.cod_producto != '{0}'\n      ORDER BY cp.cod_producto, cm.Cod_maquina\n    `;\n\n    const products = await executeQuery(sql);\n\n    // Crear estructura de respuesta\n    const costConfig: { [key: string]: any } = {};\n\n    products.forEach((product: any) => {\n      const productKey = product.cod_producto;\n\n      if (!costConfig[productKey]) {\n        costConfig[productKey] = {\n          cod_producto: product.cod_producto,\n          desc_producto: product.desc_producto,\n          costo_unitario: product.costo_unitario_default,\n          maquinas: [],\n          nota: 'Costo configurado manualmente (no viene de MAPEX)'\n        };\n      }\n\n      if (product.Cod_maquina) {\n        costConfig[productKey].maquinas.push({\n          cod_maquina: product.Cod_maquina,\n          desc_maquina: product.desc_maquina\n        });\n      }\n    });\n\n    console.log('⚙️ Configuración de costos obtenida:', Object.keys(costConfig).length, 'productos');\n\n    return NextResponse.json({\n      success: true,\n      data: costConfig,\n      timestamp: new Date().toISOString(),\n      nota: 'Costos por defecto: €0. Configure valores reales usando POST'\n    });\n\n  } catch (error) {\n    console.error('❌ Error obteniendo configuración de costos:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Error al obtener configuración de costos',\n      details: error instanceof Error ? error.message : 'Error desconocido',\n      timestamp: new Date().toISOString()\n    }, { status: 500 });\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    console.log('💾 Configurando costo personalizado');\n    const body = await request.json();\n\n    const { cod_producto, costo_unitario, maquina_id } = body;\n\n    if (!cod_producto || costo_unitario === undefined) {\n      return NextResponse.json({\n        success: false,\n        error: 'Faltan parámetros requeridos: cod_producto y costo_unitario',\n        timestamp: new Date().toISOString()\n      }, { status: 400 });\n    }\n\n    // Validar que el producto existe en MAPEX\n    const checkProductSql = `\n      SELECT cod_producto, desc_producto\n      FROM cfg_producto\n      WHERE cod_producto = @cod_producto\n        AND activo = 1\n    `;\n\n    const productExists = await executeQuery(checkProductSql, { cod_producto });\n\n    if (!productExists || productExists.length === 0) {\n      return NextResponse.json({\n        success: false,\n        error: `Producto ${cod_producto} no encontrado en MAPEX`,\n        timestamp: new Date().toISOString()\n      }, { status: 404 });\n    }\n\n    // Aquí se podría guardar en una tabla de configuración\n    // Por ahora, simularemos el guardado\n    console.log('💾 Costo configurado:', {\n      cod_producto,\n      costo_unitario,\n      maquina_id,\n      producto: productExists[0].desc_producto\n    });\n\n    return NextResponse.json({\n      success: true,\n      message: `Costo de €${costo_unitario} configurado para producto ${cod_producto}`,\n      data: {\n        cod_producto,\n        costo_unitario: parseFloat(costo_unitario),\n        maquina_id,\n        producto_descripcion: productExists[0].desc_producto\n      },\n      timestamp: new Date().toISOString()\n    });\n\n  } catch (error) {\n    console.error('❌ Error configurando costo:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Error al configurar costo',\n      details: error instanceof Error ? error.message : 'Error desconocido',\n      timestamp: new Date().toISOString()\n    }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/src/app/api/analytics/monthly/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getAllProductCosts } from '../../scada/costs-config/route';\n\nexport async function GET(request: NextRequest) {\n  try {\n    console.log('📊 Obteniendo resumen mensual');\n\n    // Usar datos de producción actuales para calcular resumen mensual aproximado\n    const productionResponse = await fetch('http://localhost:3000/api/scada/production');\n    const productionResult = await productionResponse.json();\n\n    if (!productionResult.success || !productionResult.data) {\n      return NextResponse.json({\n        success: false,\n        message: 'No se pudieron obtener datos de producción'\n      }, { status: 500 });\n    }\n\n    const machines = productionResult.data;\n    const now = new Date();\n    const daysInMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();\n\n    // Calcular totales mensuales aproximados\n    const totalOk = machines.reduce((sum: number, machine: any) => sum + (machine.ok || 0), 0);\n    const totalNok = machines.reduce((sum: number, machine: any) => sum + (machine.nok || 0), 0);\n    const totalRw = machines.reduce((sum: number, machine: any) => sum + (machine.rw || 0), 0);\n    const totalProduction = totalOk + totalNok + totalRw;\n\n    // Estimar valores mensuales basados en datos actuales\n    const estimatedMonthlyOk = Math.floor(totalOk * daysInMonth * 0.8); // 80% del día actual\n    const estimatedMonthlyNok = Math.floor(totalNok * daysInMonth * 0.8);\n    const estimatedMonthlyRw = Math.floor(totalRw * daysInMonth * 0.8);\n    const estimatedMonthlyTotal = estimatedMonthlyOk + estimatedMonthlyNok + estimatedMonthlyRw;\n\n    // Obtener costos de productos desde MAPEX\n    const productCosts = await getAllProductCosts();\n\n    // Calcular costo promedio por pieza NOK\n    const costoPromedioNok = Object.keys(productCosts).length > 0\n      ? Object.values(productCosts).reduce((sum, cost) => sum + cost, 0) / Object.keys(productCosts).length\n      : 0; // Sin productos = costo cero\n\n    console.log('💰 Costo promedio calculado:', {\n      totalProductos: Object.keys(productCosts).length,\n      costoPromedio: costoPromedioNok,\n      nota: Object.keys(productCosts).length > 0\n        ? 'Basado en costos reales de MAPEX'\n        : 'Sin productos activos - costo cero'\n    });\n\n    const data = {\n      ok: estimatedMonthlyOk,\n      nok: estimatedMonthlyNok,\n      rw: estimatedMonthlyRw,\n      total: estimatedMonthlyTotal,\n      eficiencia: totalProduction > 0 ? ((totalOk / totalProduction) * 100) : 0,\n      perdidas_eur: estimatedMonthlyNok * costoPromedioNok\n    };\n\n    console.log('📊 Resumen mensual estimado:', {\n      ...data,\n      calculo_perdidas: costoPromedioNok > 0\n        ? `${estimatedMonthlyNok} NOK × €${costoPromedioNok.toFixed(2)} = €${(estimatedMonthlyNok * costoPromedioNok).toFixed(2)}`\n        : `${estimatedMonthlyNok} NOK × €0.00 = €0.00 (sin productos activos)`,\n      nota: costoPromedioNok > 0\n        ? 'Costo basado en configuración de productos MAPEX'\n        : 'Sin productos activos - pérdidas en cero',\n      costo_promedio_usado: costoPromedioNok\n    });\n\n    return NextResponse.json({\n      success: true,\n      data,\n      timestamp: new Date().toISOString(),\n      note: 'Datos estimados basados en producción actual (MAPEX no disponible)'\n    });\n  } catch (error) {\n    console.error('❌ Error en resumen mensual:', error);\n    return NextResponse.json({\n      success: false,\n      message: 'Error al obtener resumen mensual'\n    }, { status: 500 });\n  }\n}\n\n\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,QAAQ,GAAG,CAAC;QAEZ,6EAA6E;QAC7E,MAAM,qBAAqB,MAAM,MAAM;QACvC,MAAM,mBAAmB,MAAM,mBAAmB,IAAI;QAEtD,IAAI,CAAC,iBAAiB,OAAO,IAAI,CAAC,iBAAiB,IAAI,EAAE;YACvD,OAAO,yKAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,SAAS;YACX,GAAG;gBAAE,QAAQ;YAAI;QACnB;QAEA,MAAM,WAAW,iBAAiB,IAAI;QACtC,MAAM,MAAM,IAAI;QAChB,MAAM,cAAc,IAAI,KAAK,IAAI,WAAW,IAAI,IAAI,QAAQ,KAAK,GAAG,GAAG,OAAO;QAE9E,yCAAyC;QACzC,MAAM,UAAU,SAAS,MAAM,CAAC,CAAC,KAAa,UAAiB,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,GAAG;QACxF,MAAM,WAAW,SAAS,MAAM,CAAC,CAAC,KAAa,UAAiB,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG;QAC1F,MAAM,UAAU,SAAS,MAAM,CAAC,CAAC,KAAa,UAAiB,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,GAAG;QACxF,MAAM,kBAAkB,UAAU,WAAW;QAE7C,sDAAsD;QACtD,MAAM,qBAAqB,KAAK,KAAK,CAAC,UAAU,cAAc,MAAM,qBAAqB;QACzF,MAAM,sBAAsB,KAAK,KAAK,CAAC,WAAW,cAAc;QAChE,MAAM,qBAAqB,KAAK,KAAK,CAAC,UAAU,cAAc;QAC9D,MAAM,wBAAwB,qBAAqB,sBAAsB;QAEzE,0CAA0C;QAC1C,MAAM,eAAe,MAAM,IAAA,uMAAkB;QAE7C,wCAAwC;QACxC,MAAM,mBAAmB,OAAO,IAAI,CAAC,cAAc,MAAM,GAAG,IACxD,OAAO,MAAM,CAAC,cAAc,MAAM,CAAC,CAAC,KAAK,OAAS,MAAM,MAAM,KAAK,OAAO,IAAI,CAAC,cAAc,MAAM,GACnG,GAAG,6BAA6B;QAEpC,QAAQ,GAAG,CAAC,gCAAgC;YAC1C,gBAAgB,OAAO,IAAI,CAAC,cAAc,MAAM;YAChD,eAAe;YACf,MAAM,OAAO,IAAI,CAAC,cAAc,MAAM,GAAG,IACrC,qCACA;QACN;QAEA,MAAM,OAAO;YACX,IAAI;YACJ,KAAK;YACL,IAAI;YACJ,OAAO;YACP,YAAY,kBAAkB,IAAK,AAAC,UAAU,kBAAmB,MAAO;YACxE,cAAc,sBAAsB;QACtC;QAEA,QAAQ,GAAG,CAAC,gCAAgC;YAC1C,GAAG,IAAI;YACP,kBAAkB,mBAAmB,IACjC,GAAG,oBAAoB,QAAQ,EAAE,iBAAiB,OAAO,CAAC,GAAG,IAAI,EAAE,CAAC,sBAAsB,gBAAgB,EAAE,OAAO,CAAC,IAAI,GACxH,GAAG,oBAAoB,4CAA4C,CAAC;YACxE,MAAM,mBAAmB,IACrB,qDACA;YACJ,sBAAsB;QACxB;QAEA,OAAO,yKAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,WAAW,IAAI,OAAO,WAAW;YACjC,MAAM;QACR;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,yKAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;QACX,GAAG;YAAE,QAAQ;QAAI;IACnB;AACF","debugId":null}}]
}