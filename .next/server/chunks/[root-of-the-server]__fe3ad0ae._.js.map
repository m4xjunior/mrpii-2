{"version":3,"sources":["turbopack:///[project]/Downloads/mrpii 2/lib/oee/calculations.ts"],"sourcesContent":["import { executeQuery } from '../database/connection';\n\nexport interface OEECalculation {\n  oee: number;\n  rendimiento: number;\n  disponibilidad: number;\n  calidad: number;\n}\n\nexport interface ProductionData {\n  total_ok: number;\n  total_nok: number;\n  total_rw: number;\n  tiempo_produccion_segundos: number;\n  fecha_inicio_real: string | null;\n  fecha_fin_real: string | null;\n}\n\n/**\n * Calcula OEE usando a função F_his_ct() do MAPEX (simulada)\n * Esta função simula o comportamento da função F_his_ct('WORKCENTER','','OF',...) do MAPEX\n */\nexport async function calculateOEEForOF(\n  machineCode: string,\n  codOF: string,\n  daysBack: number = 10\n): Promise<OEECalculation | null> {\n  try {\n    // Simular a função F_his_ct() do MAPEX - calcular OEE baseado em dados históricos\n    const sql = `\n      SELECT\n        -- Disponibilidad: tiempo disponible vs tiempo total\n        CASE\n          WHEN SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) -\n               ISNULL(SUM(CASE WHEN hp.id_actividad = 3 THEN CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT) ELSE 0 END), 0)\n              ) * 100.0 /\n              SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)), 2\n            )\n          ELSE 0\n        END as disponibilidad,\n\n        -- Rendimiento: unidades producidas vs velocidad nominal\n        CASE\n          WHEN cm.Rt_Rendimientonominal1 > 0 AND SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(hp.unidades_ok + hp.unidades_nok) * 3600.0) /\n              (cm.Rt_Rendimientonominal1 * (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) / 3600.0)), 2\n            )\n          ELSE 0\n        END as rendimiento,\n\n        -- Calidad: unidades OK vs total producidas\n        CASE\n          WHEN SUM(hp.unidades_ok + hp.unidades_nok) > 0 THEN\n            ROUND((SUM(hp.unidades_ok) * 100.0) / SUM(hp.unidades_ok + hp.unidades_nok), 2)\n          ELSE 0\n        END as calidad\n\n      FROM cfg_maquina cm\n      LEFT JOIN his_fase hf ON cm.rt_id_his_fase = hf.id_his_fase\n      LEFT JOIN his_prod hp ON hf.id_his_fase = hp.id_his_fase\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND cm.Rt_Cod_of = '${codOF}'\n      AND hp.fecha_fin >= DATEADD(DAY, -${daysBack}, GETDATE())\n      AND hp.id_actividad = 2 -- Producción\n      GROUP BY cm.Rt_Rendimientonominal1 -- Agrupar para agregar correctamente\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    const row = result[0];\n    const disponibilidad = Math.max(0, Math.min(100, row.disponibilidad || 0));\n    const rendimiento = Math.max(0, Math.min(100, row.rendimiento || 0));\n    const calidad = Math.max(0, Math.min(100, row.calidad || 0));\n\n    // OEE = Disponibilidad × Rendimiento × Calidad\n    const oee = Math.round((disponibilidad * rendimiento * calidad) / 10000);\n\n    return {\n      oee,\n      rendimiento,\n      disponibilidad,\n      calidad\n    };\n  } catch (error) {\n    console.error('❌ Erro ao calcular OEE para OF:', error);\n    return null;\n  }\n}\n\n/**\n * Calcula OEE por turno usando simulação da função F_his_ct('WORKCENTER','DAY','TURNO',...)\n */\nexport async function calculateOEEForTurno(\n  machineCode: string,\n  diaProductivo: string\n): Promise<OEECalculation | null> {\n  try {\n    const sql = `\n      SELECT\n        -- Disponibilidad del turno\n        CASE\n          WHEN SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) -\n               ISNULL(SUM(CASE WHEN hp.id_actividad = 3 THEN CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT) ELSE 0 END), 0)\n              ) * 100.0 /\n              SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)), 2\n            )\n          ELSE 0\n        END as disponibilidad,\n\n        -- Rendimiento del turno\n        CASE\n          WHEN cm.Rt_Rendimientonominal1 > 0 AND SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(hp.unidades_ok + hp.unidades_nok) * 3600.0) /\n              (cm.Rt_Rendimientonominal1 * (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) / 3600.0)), 2\n            )\n          ELSE 0\n        END as rendimiento,\n\n        -- Calidad del turno\n        CASE\n          WHEN SUM(hp.unidades_ok + hp.unidades_nok) > 0 THEN\n            ROUND((SUM(hp.unidades_ok) * 100.0) / SUM(hp.unidades_ok + hp.unidades_nok), 2)\n          ELSE 0\n        END as calidad\n\n      FROM cfg_maquina cm\n      LEFT JOIN his_fase hf ON cm.rt_id_his_fase = hf.id_his_fase\n      LEFT JOIN his_prod hp ON hf.id_his_fase = hp.id_his_fase\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND CONVERT(VARCHAR(10), cm.rt_dia_productivo, 111) = '${diaProductivo}'\n      AND hp.id_actividad = 2 -- Producción\n      GROUP BY cm.Rt_Rendimientonominal1 -- Agrupar para agregar correctamente\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    const row = result[0];\n    const disponibilidad = Math.max(0, Math.min(100, row.disponibilidad || 0));\n    const rendimiento = Math.max(0, Math.min(100, row.rendimiento || 0));\n    const calidad = Math.max(0, Math.min(100, row.calidad || 0));\n\n    const oee = Math.round((disponibilidad * rendimiento * calidad) / 10000);\n\n    return {\n      oee,\n      rendimiento,\n      disponibilidad,\n      calidad\n    };\n  } catch (error) {\n    console.error('❌ Erro ao calcular OEE para turno:', error);\n    return null;\n  }\n}\n\n/**\n * Obtém dados de produção detalhados para uma OF\n */\nexport async function getProductionDataForOF(\n  machineCode: string,\n  codOF: string\n): Promise<ProductionData | null> {\n  try {\n    const sql = `\n      SELECT\n        SUM(hp.unidades_ok) as total_ok,\n        SUM(hp.unidades_nok) as total_nok,\n        SUM(hp.unidades_repro) as total_rw,\n        SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) as tiempo_produccion_segundos,\n        MIN(hp.fecha_ini) as fecha_inicio_real,\n        MAX(hp.fecha_fin) as fecha_fin_real\n      FROM his_prod hp\n      INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase\n      INNER JOIN his_of ho ON hf.id_his_of = ho.id_his_of\n      WHERE ho.cod_of = '${codOF}'\n      AND hp.id_actividad = 2 -- Producción\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    return result[0] as ProductionData;\n  } catch (error) {\n    console.error('❌ Erro ao obter dados de produção:', error);\n    return null;\n  }\n}\n\n/**\n * Calcula tempo restante para completar uma OF\n */\nexport function calculateRemainingTime(\n  remainingPieces: number,\n  velocity: number\n): string {\n  if (velocity > 0 && remainingPieces > 0) {\n    const remainingHours = remainingPieces / velocity;\n    if (remainingHours >= 24) {\n      return `${Math.round(remainingHours / 24)}d`;\n    } else {\n      return `${remainingHours.toFixed(1)}h`;\n    }\n  }\n  return 'N/A';\n}\n\n/**\n * Calcula percentual de avanço de uma OF\n */\nexport function calculateProgress(\n  totalProduced: number,\n  plannedUnits: number\n): number {\n  if (plannedUnits > 0) {\n    return Math.round((totalProduced / plannedUnits) * 100);\n  }\n  return 0;\n}\n\n/**\n * Calcula OEE (função de compatibilidade)\n */\nexport async function calcularOEE(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<OEECalculation | null> {\n  return calculateOEEForOF(machineCode, '', 30); // Simplificado\n}\n\n/**\n * Calcula OEE ponderado (função de compatibilidade)\n */\nexport async function calcularOEEPonderado(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<number> {\n  const oee = await calculateOEEForOF(machineCode, '', 30);\n  return oee?.oee || 0;\n}\n\n/**\n * Gera alertas baseado em dados OEE (função de compatibilidade)\n */\nexport async function generarAlertas(\n  machineCode: string\n): Promise<any[]> {\n  try {\n    const oee = await calculateOEEForOF(machineCode, '', 1);\n    const alerts = [];\n\n    if (oee) {\n      if (oee.oee < 60) {\n        alerts.push({\n          type: 'danger',\n          message: 'OEE crítico: abaixo de 60%',\n          value: oee.oee\n        });\n      } else if (oee.oee < 75) {\n        alerts.push({\n          type: 'warning',\n          message: 'OEE baixo: abaixo de 75%',\n          value: oee.oee\n        });\n      }\n\n      if (oee.disponibilidad < 80) {\n        alerts.push({\n          type: 'warning',\n          message: 'Disponibilidade baixa',\n          value: oee.disponibilidad\n        });\n      }\n\n      if (oee.calidad < 95) {\n        alerts.push({\n          type: 'warning',\n          message: 'Qualidade baixa',\n          value: oee.calidad\n        });\n      }\n    }\n\n    return alerts;\n  } catch (error) {\n    console.error('Erro ao gerar alertas:', error);\n    return [];\n  }\n}\n\n/**\n * Análise Pareto de causas de paros\n */\nexport async function analizarParetoCausas(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<any[]> {\n  try {\n    const sql = `\n      SELECT\n        cp.desc_paro as causa,\n        SUM(DATEDIFF(MINUTE, hpp.fecha_ini, hpp.fecha_fin)) as tiempo_total_minutos,\n        COUNT(*) as cantidad_paros\n      FROM his_prod hp\n      INNER JOIN his_prod_paro hpp ON hp.id_his_prod = hpp.id_his_prod\n      INNER JOIN cfg_paro cp ON hpp.id_paro = cp.id_paro\n      INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND hpp.fecha_ini >= '${startDate.toISOString()}'\n      AND hpp.fecha_ini <= '${endDate.toISOString()}'\n      GROUP BY cp.desc_paro\n      ORDER BY tiempo_total_minutos DESC\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    // Calcular percentual cumulativo (Pareto 80/20)\n    const totalTiempo = result.reduce((sum, item) => sum + (item.tiempo_total_minutos || 0), 0);\n    let tiempoAcumulado = 0;\n\n    return result.map(item => {\n      tiempoAcumulado += item.tiempo_total_minutos || 0;\n      return {\n        causa: item.causa || 'Sin causa',\n        tiempo_total_minutos: item.tiempo_total_minutos || 0,\n        cantidad_paros: item.cantidad_paros || 0,\n        porcentaje: totalTiempo > 0 ? Math.round((item.tiempo_total_minutos / totalTiempo) * 100) : 0,\n        porcentaje_acumulado: totalTiempo > 0 ? Math.round((tiempoAcumulado / totalTiempo) * 100) : 0\n      };\n    });\n  } catch (error) {\n    console.error('Erro ao analisar Pareto de causas:', error);\n    return [];\n  }\n}"],"names":[],"mappings":"w9DAAA,IAAA,EAAA,EAAA,CAAA,CAAA,OAsBO,eAAe,EACpB,CAAmB,CACnB,CAAa,CACb,EAAmB,EAAE,EAErB,GAAI,CAEF,IAAM,EAAM,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8BAkCa,EAAE,EAAY;0BAClB,EAAE,EAAM;wCACM,EAAE,EAAS;;;IAG/C,CAAC,CAEK,EAAS,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,OAAK,EAAW,SAElD,GAAsB,IAAlB,EAAO,MAAM,EAAU,CAAC,CAAM,CAAC,EAAE,CACnC,CADqC,MAC9B,KAGT,IAAM,EAAM,CAAM,CAAC,EAAE,CACf,EAAiB,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,IAAK,EAAI,cAAc,EAAI,IACjE,EAAc,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,IAAK,EAAI,WAAW,EAAI,IAC3D,EAAU,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,IAAK,EAAI,OAAO,EAAI,IAKzD,MAAO,CACL,IAHU,KAAK,KAAK,CAAE,EAAiB,EAAc,EAAW,iBAIhE,iBACA,UACA,CACF,CACF,CAAE,MAAO,EAAO,CAEd,OADA,QAAQ,KAAK,CAAC,kCAAmC,GAC1C,IACT,CACF,CAkHO,SAAS,EACd,CAAuB,CACvB,CAAgB,EAEhB,GAAI,EAAW,GAAK,EAAkB,EAAG,CACvC,IAAM,EAAiB,EAAkB,SACzC,AAAI,GAAkB,GACb,CADiB,AACjB,EAAG,KAAK,KAAK,CAAC,EAAiB,IAAI,CAAC,CAAC,CAErC,CAAA,EAAG,EAAe,OAAO,CAAC,GAAG,CAAC,CAAC,AAE1C,CACA,MAAO,KACT,CAyCO,eAAe,EACpB,CAAmB,EAEnB,GAAI,CACF,IAAM,EAAM,MAAM,EAAkB,EAAa,GAAI,GAC/C,EAAS,EAAE,CAkCjB,OAhCI,IACE,CADG,CACC,GAAG,CAAG,GACZ,CADgB,CACT,IAAI,CAAC,CACV,KAAM,SACN,QAAS,6BACT,MAAO,EAAI,GAAG,AAChB,GACS,EAAI,GAAG,CAAG,IAAI,AACvB,EAAO,IAAI,CAAC,CACV,KAAM,UACN,QAAS,2BACT,MAAO,EAAI,GAAG,AAChB,GAGE,EAAI,cAAc,CAAG,IAAI,AAC3B,EAAO,IAAI,CAAC,CACV,KAAM,UACN,QAAS,wBACT,MAAO,EAAI,cAAc,AAC3B,GAGE,EAAI,OAAO,CAAG,IAChB,AADoB,EACb,IAAI,CAAC,CACV,KAAM,UACN,QAAS,kBACT,MAAO,EAAI,OAAO,AACpB,IAIG,CACT,CAAE,MAAO,EAAO,CAEd,OADA,QAAQ,KAAK,CAAC,yBAA0B,GACjC,EAAE,AACX,CACF"}