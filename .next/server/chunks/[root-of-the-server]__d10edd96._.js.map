{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/lib/database/connection.ts"],"sourcesContent":["import { Connection, Request, TYPES } from 'tedious';\n\n// Configuraciones para múltiples bases de datos como en el PHP original\nconst baseConfig: any = {\n  server: process.env.DB_SERVER || '10.0.0.45',\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: process.env.DB_USER || 'sa',\n      password: process.env.DB_PASSWORD || 'Mapexdd2017',\n    },\n  },\n  options: {\n    port: parseInt(process.env.DB_PORT || '1433'),\n    encrypt: false,\n    trustServerCertificate: true,\n    connectTimeout: 30000,\n    requestTimeout: 30000,\n    enableArithAbort: true,\n  },\n};\n\n// Configuraciones específicas para cada base de datos\nconst mapexConfig: any = {\n  ...baseConfig,\n  options: {\n    ...baseConfig.options,\n    database: process.env.DB_NAME || 'mapexbp_Test',\n  },\n};\n\nconst sageConfig: any = {\n  ...baseConfig,\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: 'sa',\n      password: 'admin000',\n    },\n  },\n  options: {\n    ...baseConfig.options,\n    database: 'SAGE',\n  },\n};\n\nconst whalesConfig: any = {\n  ...baseConfig,\n  authentication: {\n    type: 'default' as const,\n    options: {\n      userName: 'sa',\n      password: '87cc88bb89.',\n    },\n  },\n  options: {\n    ...baseConfig.options,\n    database: 'WHALES',\n  },\n};\n\n// Função para criar uma nova conexão para cada query (evita conflitos de estado)\nexport async function getDbConnection(database: 'mapex' | 'sage' | 'whales' = 'mapex'): Promise<Connection> {\n  let config: any;\n  switch (database) {\n    case 'mapex':\n      config = mapexConfig;\n      break;\n    case 'sage':\n      config = sageConfig;\n      break;\n    case 'whales':\n      config = whalesConfig;\n      break;\n    default:\n      config = mapexConfig;\n  }\n\n  const connection = new Connection(config);\n\n  return new Promise((resolve, reject) => {\n    connection.on('connect', (err) => {\n      if (err) {\n        console.error(`❌ Erro ao conectar à base ${database.toUpperCase()}:`, err);\n        reject(err);\n      } else {\n        console.log(`✅ Nova conexão criada para ${database.toUpperCase()}`);\n        resolve(connection);\n      }\n    });\n\n    connection.on('error', (err) => {\n      console.error(`❌ Erro na conexão ${database.toUpperCase()}:`, err);\n      reject(err);\n    });\n\n    // Não definir on('end') aqui pois vamos fechar manualmente\n\n    connection.connect();\n  });\n}\n\nexport async function executeQuery<T = any>(\n  sql: string,\n  parameters?: { [key: string]: any },\n  database: 'mapex' | 'sage' | 'whales' = 'mapex'\n): Promise<T[]> {\n  const conn = await getDbConnection(database);\n\n  return new Promise((resolve, reject) => {\n    const results: T[] = [];\n\n    const request = new Request(sql, (err) => {\n      // Sempre fechar a conexão após completar a query\n      try {\n        conn.close();\n      } catch (closeErr) {\n        console.warn('⚠️ Erro ao fechar conexão:', closeErr);\n      }\n\n      if (err) {\n        console.error(`❌ Erro na query ${database.toUpperCase()}:`, err);\n        console.error('SQL:', sql.substring(0, 200) + '...');\n        reject(err);\n      } else {\n        resolve(results);\n      }\n    });\n\n    // Adicionar parâmetros se fornecidos\n    if (parameters) {\n      Object.entries(parameters).forEach(([key, value]) => {\n        let type: any = TYPES.NVarChar;\n        if (typeof value === 'number') {\n          type = Number.isInteger(value) ? TYPES.Int : TYPES.Float;\n        } else if (typeof value === 'boolean') {\n          type = TYPES.Bit;\n        } else if (value instanceof Date) {\n          type = TYPES.DateTime;\n        }\n        request.addParameter(key, type, value);\n      });\n    }\n\n    request.on('row', (columns: any) => {\n      const row: any = {};\n      columns.forEach((column: any) => {\n        row[column.metadata.colName] = column.value;\n      });\n      results.push(row);\n    });\n\n    try {\n      conn.execSql(request);\n    } catch (execErr) {\n      // Se houver erro na execução, fechar conexão e rejeitar\n      try {\n        conn.close();\n      } catch (closeErr) {\n        console.warn('⚠️ Erro ao fechar conexão após falha:', closeErr);\n      }\n      reject(execErr);\n    }\n  });\n}\n\nexport async function closeDbConnection(database?: 'mapex' | 'sage' | 'whales'): Promise<void> {\n  // Como agora criamos uma nova conexão para cada query e fechamos automaticamente,\n  // esta função é mantida por compatibilidade mas não faz mais sentido\n  console.log('ℹ️ Conexões agora são gerenciadas automaticamente por query');\n}\n\n// Função para testar conectividade\nexport async function testConnections(): Promise<{ [key: string]: boolean }> {\n  const results: { [key: string]: boolean } = {};\n\n  for (const db of ['mapex', 'sage', 'whales'] as const) {\n    try {\n      await executeQuery('SELECT 1 as test', undefined, db);\n      results[db] = true;\n      console.log(`✅ Teste de conectividade ${db.toUpperCase()}: OK`);\n    } catch (error) {\n      results[db] = false;\n      console.error(`❌ Teste de conectividade ${db.toUpperCase()}: FALHOU`, error);\n    }\n  }\n\n  return results;\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/lib/oee/calculations.ts"],"sourcesContent":["import { executeQuery } from '../database/connection';\n\nexport interface OEECalculation {\n  oee: number;\n  rendimiento: number;\n  disponibilidad: number;\n  calidad: number;\n}\n\nexport interface ProductionData {\n  total_ok: number;\n  total_nok: number;\n  total_rw: number;\n  tiempo_produccion_segundos: number;\n  fecha_inicio_real: string | null;\n  fecha_fin_real: string | null;\n}\n\n/**\n * Calcula OEE usando a função F_his_ct() do MAPEX (simulada)\n * Esta função simula o comportamento da função F_his_ct('WORKCENTER','','OF',...) do MAPEX\n */\nexport async function calculateOEEForOF(\n  machineCode: string,\n  codOF: string,\n  daysBack: number = 10\n): Promise<OEECalculation | null> {\n  try {\n    // Simular a função F_his_ct() do MAPEX - calcular OEE baseado em dados históricos\n    const sql = `\n      SELECT\n        -- Disponibilidad: tiempo disponible vs tiempo total\n        CASE\n          WHEN SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) -\n               ISNULL(SUM(CASE WHEN hp.id_actividad = 3 THEN CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT) ELSE 0 END), 0)\n              ) * 100.0 /\n              SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)), 2\n            )\n          ELSE 0\n        END as disponibilidad,\n\n        -- Rendimiento: unidades producidas vs velocidad nominal\n        CASE\n          WHEN cm.Rt_Rendimientonominal1 > 0 AND SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(hp.unidades_ok + hp.unidades_nok) * 3600.0) /\n              (cm.Rt_Rendimientonominal1 * (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) / 3600.0)), 2\n            )\n          ELSE 0\n        END as rendimiento,\n\n        -- Calidad: unidades OK vs total producidas\n        CASE\n          WHEN SUM(hp.unidades_ok + hp.unidades_nok) > 0 THEN\n            ROUND((SUM(hp.unidades_ok) * 100.0) / SUM(hp.unidades_ok + hp.unidades_nok), 2)\n          ELSE 0\n        END as calidad\n\n      FROM cfg_maquina cm\n      LEFT JOIN his_fase hf ON cm.rt_id_his_fase = hf.id_his_fase\n      LEFT JOIN his_prod hp ON hf.id_his_fase = hp.id_his_fase\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND cm.Rt_Cod_of = '${codOF}'\n      AND hp.fecha_fin >= DATEADD(DAY, -${daysBack}, GETDATE())\n      AND hp.id_actividad = 2 -- Producción\n      GROUP BY cm.Rt_Rendimientonominal1 -- Agrupar para agregar correctamente\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    const row = result[0];\n    const disponibilidad = Math.max(0, Math.min(100, row.disponibilidad || 0));\n    const rendimiento = Math.max(0, Math.min(100, row.rendimiento || 0));\n    const calidad = Math.max(0, Math.min(100, row.calidad || 0));\n\n    // OEE = Disponibilidad × Rendimiento × Calidad\n    const oee = Math.round((disponibilidad * rendimiento * calidad) / 10000);\n\n    return {\n      oee,\n      rendimiento,\n      disponibilidad,\n      calidad\n    };\n  } catch (error) {\n    console.error('❌ Erro ao calcular OEE para OF:', error);\n    return null;\n  }\n}\n\n/**\n * Calcula OEE por turno usando simulação da função F_his_ct('WORKCENTER','DAY','TURNO',...)\n */\nexport async function calculateOEEForTurno(\n  machineCode: string,\n  diaProductivo: string\n): Promise<OEECalculation | null> {\n  try {\n    const sql = `\n      SELECT\n        -- Disponibilidad del turno\n        CASE\n          WHEN SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) -\n               ISNULL(SUM(CASE WHEN hp.id_actividad = 3 THEN CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT) ELSE 0 END), 0)\n              ) * 100.0 /\n              SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)), 2\n            )\n          ELSE 0\n        END as disponibilidad,\n\n        -- Rendimiento del turno\n        CASE\n          WHEN cm.Rt_Rendimientonominal1 > 0 AND SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) > 0 THEN\n            ROUND(\n              (SUM(hp.unidades_ok + hp.unidades_nok) * 3600.0) /\n              (cm.Rt_Rendimientonominal1 * (SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) / 3600.0)), 2\n            )\n          ELSE 0\n        END as rendimiento,\n\n        -- Calidad del turno\n        CASE\n          WHEN SUM(hp.unidades_ok + hp.unidades_nok) > 0 THEN\n            ROUND((SUM(hp.unidades_ok) * 100.0) / SUM(hp.unidades_ok + hp.unidades_nok), 2)\n          ELSE 0\n        END as calidad\n\n      FROM cfg_maquina cm\n      LEFT JOIN his_fase hf ON cm.rt_id_his_fase = hf.id_his_fase\n      LEFT JOIN his_prod hp ON hf.id_his_fase = hp.id_his_fase\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND CONVERT(VARCHAR(10), cm.rt_dia_productivo, 111) = '${diaProductivo}'\n      AND hp.id_actividad = 2 -- Producción\n      GROUP BY cm.Rt_Rendimientonominal1 -- Agrupar para agregar correctamente\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    const row = result[0];\n    const disponibilidad = Math.max(0, Math.min(100, row.disponibilidad || 0));\n    const rendimiento = Math.max(0, Math.min(100, row.rendimiento || 0));\n    const calidad = Math.max(0, Math.min(100, row.calidad || 0));\n\n    const oee = Math.round((disponibilidad * rendimiento * calidad) / 10000);\n\n    return {\n      oee,\n      rendimiento,\n      disponibilidad,\n      calidad\n    };\n  } catch (error) {\n    console.error('❌ Erro ao calcular OEE para turno:', error);\n    return null;\n  }\n}\n\n/**\n * Obtém dados de produção detalhados para uma OF\n */\nexport async function getProductionDataForOF(\n  machineCode: string,\n  codOF: string\n): Promise<ProductionData | null> {\n  try {\n    const sql = `\n      SELECT\n        SUM(hp.unidades_ok) as total_ok,\n        SUM(hp.unidades_nok) as total_nok,\n        SUM(hp.unidades_repro) as total_rw,\n        SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) as tiempo_produccion_segundos,\n        MIN(hp.fecha_ini) as fecha_inicio_real,\n        MAX(hp.fecha_fin) as fecha_fin_real\n      FROM his_prod hp\n      INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase\n      INNER JOIN his_of ho ON hf.id_his_of = ho.id_his_of\n      WHERE ho.cod_of = '${codOF}'\n      AND hp.id_actividad = 2 -- Producción\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    if (result.length === 0 || !result[0]) {\n      return null;\n    }\n\n    return result[0] as ProductionData;\n  } catch (error) {\n    console.error('❌ Erro ao obter dados de produção:', error);\n    return null;\n  }\n}\n\n/**\n * Calcula tempo restante para completar uma OF\n */\nexport function calculateRemainingTime(\n  remainingPieces: number,\n  velocity: number\n): string {\n  if (velocity > 0 && remainingPieces > 0) {\n    const remainingHours = remainingPieces / velocity;\n    if (remainingHours >= 24) {\n      return `${Math.round(remainingHours / 24)}d`;\n    } else {\n      return `${remainingHours.toFixed(1)}h`;\n    }\n  }\n  return 'N/A';\n}\n\n/**\n * Calcula percentual de avanço de uma OF\n */\nexport function calculateProgress(\n  totalProduced: number,\n  plannedUnits: number\n): number {\n  if (plannedUnits > 0) {\n    return Math.round((totalProduced / plannedUnits) * 100);\n  }\n  return 0;\n}\n\n/**\n * Calcula OEE (função de compatibilidade)\n */\nexport async function calcularOEE(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<OEECalculation | null> {\n  return calculateOEEForOF(machineCode, '', 30); // Simplificado\n}\n\n/**\n * Calcula OEE ponderado (função de compatibilidade)\n */\nexport async function calcularOEEPonderado(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<number> {\n  const oee = await calculateOEEForOF(machineCode, '', 30);\n  return oee?.oee || 0;\n}\n\n/**\n * Gera alertas baseado em dados OEE (função de compatibilidade)\n */\nexport async function generarAlertas(\n  machineCode: string\n): Promise<any[]> {\n  try {\n    const oee = await calculateOEEForOF(machineCode, '', 1);\n    const alerts = [];\n\n    if (oee) {\n      if (oee.oee < 60) {\n        alerts.push({\n          type: 'danger',\n          message: 'OEE crítico: abaixo de 60%',\n          value: oee.oee\n        });\n      } else if (oee.oee < 75) {\n        alerts.push({\n          type: 'warning',\n          message: 'OEE baixo: abaixo de 75%',\n          value: oee.oee\n        });\n      }\n\n      if (oee.disponibilidad < 80) {\n        alerts.push({\n          type: 'warning',\n          message: 'Disponibilidade baixa',\n          value: oee.disponibilidad\n        });\n      }\n\n      if (oee.calidad < 95) {\n        alerts.push({\n          type: 'warning',\n          message: 'Qualidade baixa',\n          value: oee.calidad\n        });\n      }\n    }\n\n    return alerts;\n  } catch (error) {\n    console.error('Erro ao gerar alertas:', error);\n    return [];\n  }\n}\n\n/**\n * Análise Pareto de causas de paros\n */\nexport async function analizarParetoCausas(\n  machineCode: string,\n  startDate: Date,\n  endDate: Date\n): Promise<any[]> {\n  try {\n    const sql = `\n      SELECT\n        cp.desc_paro as causa,\n        SUM(DATEDIFF(MINUTE, hpp.fecha_ini, hpp.fecha_fin)) as tiempo_total_minutos,\n        COUNT(*) as cantidad_paros\n      FROM his_prod hp\n      INNER JOIN his_prod_paro hpp ON hp.id_his_prod = hpp.id_his_prod\n      INNER JOIN cfg_paro cp ON hpp.id_paro = cp.id_paro\n      INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n      WHERE cm.Cod_maquina = '${machineCode}'\n      AND hpp.fecha_ini >= '${startDate.toISOString()}'\n      AND hpp.fecha_ini <= '${endDate.toISOString()}'\n      GROUP BY cp.desc_paro\n      ORDER BY tiempo_total_minutos DESC\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n\n    // Calcular percentual cumulativo (Pareto 80/20)\n    const totalTiempo = result.reduce((sum, item) => sum + (item.tiempo_total_minutos || 0), 0);\n    let tiempoAcumulado = 0;\n\n    return result.map(item => {\n      tiempoAcumulado += item.tiempo_total_minutos || 0;\n      return {\n        causa: item.causa || 'Sin causa',\n        tiempo_total_minutos: item.tiempo_total_minutos || 0,\n        cantidad_paros: item.cantidad_paros || 0,\n        porcentaje: totalTiempo > 0 ? Math.round((item.tiempo_total_minutos / totalTiempo) * 100) : 0,\n        porcentaje_acumulado: totalTiempo > 0 ? Math.round((tiempoAcumulado / totalTiempo) * 100) : 0\n      };\n    });\n  } catch (error) {\n    console.error('Erro ao analisar Pareto de causas:', error);\n    return [];\n  }\n}"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;AAsBO,eAAe,kBACpB,WAAmB,EACnB,KAAa,EACb,WAAmB,EAAE;IAErB,IAAI;QACF,kFAAkF;QAClF,MAAM,MAAM,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8BAkCa,EAAE,YAAY;0BAClB,EAAE,MAAM;wCACM,EAAE,SAAS;;;IAG/C,CAAC;QAED,MAAM,SAAS,MAAM,IAAA,wKAAY,EAAC,KAAK,WAAW;QAElD,IAAI,OAAO,MAAM,KAAK,KAAK,CAAC,MAAM,CAAC,EAAE,EAAE;YACrC,OAAO;QACT;QAEA,MAAM,MAAM,MAAM,CAAC,EAAE;QACrB,MAAM,iBAAiB,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,KAAK,IAAI,cAAc,IAAI;QACvE,MAAM,cAAc,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,KAAK,IAAI,WAAW,IAAI;QACjE,MAAM,UAAU,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,KAAK,IAAI,OAAO,IAAI;QAEzD,+CAA+C;QAC/C,MAAM,MAAM,KAAK,KAAK,CAAC,AAAC,iBAAiB,cAAc,UAAW;QAElE,OAAO;YACL;YACA;YACA;YACA;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO;IACT;AACF;AAKO,eAAe,qBACpB,WAAmB,EACnB,aAAqB;IAErB,IAAI;QACF,MAAM,MAAM,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8BAkCa,EAAE,YAAY;6DACiB,EAAE,cAAc;;;IAGzE,CAAC;QAED,MAAM,SAAS,MAAM,IAAA,wKAAY,EAAC,KAAK,WAAW;QAElD,IAAI,OAAO,MAAM,KAAK,KAAK,CAAC,MAAM,CAAC,EAAE,EAAE;YACrC,OAAO;QACT;QAEA,MAAM,MAAM,MAAM,CAAC,EAAE;QACrB,MAAM,iBAAiB,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,KAAK,IAAI,cAAc,IAAI;QACvE,MAAM,cAAc,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,KAAK,IAAI,WAAW,IAAI;QACjE,MAAM,UAAU,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,KAAK,IAAI,OAAO,IAAI;QAEzD,MAAM,MAAM,KAAK,KAAK,CAAC,AAAC,iBAAiB,cAAc,UAAW;QAElE,OAAO;YACL;YACA;YACA;YACA;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sCAAsC;QACpD,OAAO;IACT;AACF;AAKO,eAAe,uBACpB,WAAmB,EACnB,KAAa;IAEb,IAAI;QACF,MAAM,MAAM,CAAC;;;;;;;;;;;yBAWQ,EAAE,MAAM;;IAE7B,CAAC;QAED,MAAM,SAAS,MAAM,IAAA,wKAAY,EAAC,KAAK,WAAW;QAElD,IAAI,OAAO,MAAM,KAAK,KAAK,CAAC,MAAM,CAAC,EAAE,EAAE;YACrC,OAAO;QACT;QAEA,OAAO,MAAM,CAAC,EAAE;IAClB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sCAAsC;QACpD,OAAO;IACT;AACF;AAKO,SAAS,uBACd,eAAuB,EACvB,QAAgB;IAEhB,IAAI,WAAW,KAAK,kBAAkB,GAAG;QACvC,MAAM,iBAAiB,kBAAkB;QACzC,IAAI,kBAAkB,IAAI;YACxB,OAAO,GAAG,KAAK,KAAK,CAAC,iBAAiB,IAAI,CAAC,CAAC;QAC9C,OAAO;YACL,OAAO,GAAG,eAAe,OAAO,CAAC,GAAG,CAAC,CAAC;QACxC;IACF;IACA,OAAO;AACT;AAKO,SAAS,kBACd,aAAqB,EACrB,YAAoB;IAEpB,IAAI,eAAe,GAAG;QACpB,OAAO,KAAK,KAAK,CAAC,AAAC,gBAAgB,eAAgB;IACrD;IACA,OAAO;AACT;AAKO,eAAe,YACpB,WAAmB,EACnB,SAAe,EACf,OAAa;IAEb,OAAO,kBAAkB,aAAa,IAAI,KAAK,eAAe;AAChE;AAKO,eAAe,qBACpB,WAAmB,EACnB,SAAe,EACf,OAAa;IAEb,MAAM,MAAM,MAAM,kBAAkB,aAAa,IAAI;IACrD,OAAO,KAAK,OAAO;AACrB;AAKO,eAAe,eACpB,WAAmB;IAEnB,IAAI;QACF,MAAM,MAAM,MAAM,kBAAkB,aAAa,IAAI;QACrD,MAAM,SAAS,EAAE;QAEjB,IAAI,KAAK;YACP,IAAI,IAAI,GAAG,GAAG,IAAI;gBAChB,OAAO,IAAI,CAAC;oBACV,MAAM;oBACN,SAAS;oBACT,OAAO,IAAI,GAAG;gBAChB;YACF,OAAO,IAAI,IAAI,GAAG,GAAG,IAAI;gBACvB,OAAO,IAAI,CAAC;oBACV,MAAM;oBACN,SAAS;oBACT,OAAO,IAAI,GAAG;gBAChB;YACF;YAEA,IAAI,IAAI,cAAc,GAAG,IAAI;gBAC3B,OAAO,IAAI,CAAC;oBACV,MAAM;oBACN,SAAS;oBACT,OAAO,IAAI,cAAc;gBAC3B;YACF;YAEA,IAAI,IAAI,OAAO,GAAG,IAAI;gBACpB,OAAO,IAAI,CAAC;oBACV,MAAM;oBACN,SAAS;oBACT,OAAO,IAAI,OAAO;gBACpB;YACF;QACF;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,EAAE;IACX;AACF;AAKO,eAAe,qBACpB,WAAmB,EACnB,SAAe,EACf,OAAa;IAEb,IAAI;QACF,MAAM,MAAM,CAAC;;;;;;;;;8BASa,EAAE,YAAY;4BAChB,EAAE,UAAU,WAAW,GAAG;4BAC1B,EAAE,QAAQ,WAAW,GAAG;;;IAGhD,CAAC;QAED,MAAM,SAAS,MAAM,IAAA,wKAAY,EAAC,KAAK,WAAW;QAElD,gDAAgD;QAChD,MAAM,cAAc,OAAO,MAAM,CAAC,CAAC,KAAK,OAAS,MAAM,CAAC,KAAK,oBAAoB,IAAI,CAAC,GAAG;QACzF,IAAI,kBAAkB;QAEtB,OAAO,OAAO,GAAG,CAAC,CAAA;YAChB,mBAAmB,KAAK,oBAAoB,IAAI;YAChD,OAAO;gBACL,OAAO,KAAK,KAAK,IAAI;gBACrB,sBAAsB,KAAK,oBAAoB,IAAI;gBACnD,gBAAgB,KAAK,cAAc,IAAI;gBACvC,YAAY,cAAc,IAAI,KAAK,KAAK,CAAC,AAAC,KAAK,oBAAoB,GAAG,cAAe,OAAO;gBAC5F,sBAAsB,cAAc,IAAI,KAAK,KAAK,CAAC,AAAC,kBAAkB,cAAe,OAAO;YAC9F;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sCAAsC;QACpD,OAAO,EAAE;IACX;AACF","debugId":null}},
    {"offset": {"line": 698, "column": 0}, "map": {"version":3,"sources":["file:///Users/maxmeireles/Downloads/mrpii%202/src/app/api/scada/machine-details/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { executeQuery } from '../../../../../lib/database/connection';\nimport { calculateOEEForOF, calculateRemainingTime } from '../../../../../lib/oee/calculations';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { machineId, tab } = await request.json();\n\n    if (!machineId || !tab) {\n      return NextResponse.json({\n        success: false,\n        error: 'Parâmetros machineId e tab são obrigatórios'\n      }, { status: 400 });\n    }\n\n    let data;\n\n    switch (tab) {\n      case 'of':\n        data = await getOFData(machineId);\n        break;\n      case 'paros':\n        data = await getParosData(machineId);\n        break;\n      case 'produccion':\n        data = await getProduccionData(machineId);\n        break;\n      case 'oee':\n        data = await getOEEData(machineId);\n        break;\n      case 'pedidos':\n        data = await getPedidosData(machineId);\n        break;\n      case 'historico':\n        data = await getHistoricoData(machineId);\n        break;\n      case 'ventas':\n        data = await getVentasData(machineId);\n        break;\n      default:\n        return NextResponse.json({\n          success: false,\n          error: 'Tab não válida'\n        }, { status: 400 });\n    }\n\n    return NextResponse.json({\n      success: true,\n      data,\n      tab,\n      machineId,\n      timestamp: new Date().toISOString()\n    });\n\n  } catch (error) {\n    console.error('❌ Erro ao buscar detalhes da máquina:', error);\n    return NextResponse.json({\n      success: false,\n      error: 'Erro interno do servidor',\n      message: error instanceof Error ? error.message : 'Erro desconhecido'\n    }, { status: 500 });\n  }\n}\n\nasync function getOFData(machineId: string) {\n  try {\n    // Obtener información básica de la máquina y OF\n    const sql = `\n      SELECT\n        cm.Rt_Cod_of, cm.rt_Cod_producto, cm.Rt_Desc_producto,\n        cm.Rt_Unidades_planning, cm.rt_dia_productivo, cm.rt_desc_turno,\n        cm.Rt_Unidades_ok_of as Unidades_ok, cm.Rt_Unidades_nok_of as Rt_Unidades_nok, cm.Rt_Unidades_repro_of as Unidades_rw,\n        cm.f_velocidad, cm.rt_id_his_fase, cm.rt_Desc_operario,\n        ho.fecha_ini, ho.fecha_fin as fecha_fin_prevista, ho.id_his_of\n      FROM cfg_maquina cm\n      LEFT JOIN his_of ho ON cm.Rt_Cod_of = ho.cod_of\n      WHERE cm.Cod_maquina = '${machineId}'\n    `;\n\n    const result = await executeQuery(sql, undefined, 'mapex');\n    if (result.length === 0) return null;\n\n    const row = result[0];\n    const cod_of = row.Rt_Cod_of;\n    const id_his_of = row.id_his_of;\n\n    // Obtener datos OEE para la OF usando nossa função simulada\n    let oee_data = null;\n    try {\n      oee_data = await calculateOEEForOF(machineId, cod_of);\n    } catch (error) {\n      console.warn('⚠️ Erro ao calcular OEE para OF:', error);\n    }\n\n    // Obtener datos de producción detallados\n    let produccion_data = null;\n    if (id_his_of) {\n      const sql_produccion = `\n        SELECT\n          SUM(hp.unidades_ok) as total_ok,\n          SUM(hp.unidades_nok) as total_nok,\n          SUM(hp.unidades_repro) as total_rw,\n          SUM(CAST(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin) AS BIGINT)) as tiempo_produccion_segundos,\n          MIN(hp.fecha_ini) as fecha_inicio_real,\n          MAX(hp.fecha_fin) as fecha_fin_real\n        FROM his_prod hp\n        INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase\n        WHERE hf.id_his_of = '${id_his_of}'\n        AND hp.id_actividad = 2\n      `;\n\n      const produccion_result = await executeQuery(sql_produccion, undefined, 'mapex');\n      produccion_data = produccion_result[0] || null;\n    }\n\n    // Obtener datos de paros para esta OF\n    let paros_data = null;\n    if (id_his_of) {\n      const sql_paros = `\n        SELECT\n          SUM(CAST(DATEDIFF(SECOND, hpp.fecha_ini, hpp.fecha_fin) AS BIGINT)) as tiempo_paros_segundos,\n          COUNT(DISTINCT hpp.Id_operario) as num_operarios\n        FROM his_prod hp\n        INNER JOIN his_prod_paro hpp ON hp.id_his_prod = hpp.id_his_prod\n        INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase\n        WHERE hf.id_his_of = '${id_his_of}'\n      `;\n\n      const paros_result = await executeQuery(sql_paros, undefined, 'mapex');\n      paros_data = paros_result[0] || null;\n    }\n\n    // Obtener los principales paros\n    let principales_paros = [];\n    if (id_his_of) {\n      const sql_principales_paros = `\n        SELECT\n          cp.desc_paro,\n          SUM(CAST(DATEDIFF(SECOND, hpp.fecha_ini, hpp.fecha_fin) AS BIGINT)) as tiempo_segundos\n        FROM his_prod hp\n        INNER JOIN his_prod_paro hpp ON hp.id_his_prod = hpp.id_his_prod\n        INNER JOIN cfg_paro cp ON hpp.id_paro = cp.id_paro\n        INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase\n        WHERE hf.id_his_of = '${id_his_of}'\n        GROUP BY cp.desc_paro\n        ORDER BY tiempo_segundos DESC\n      `;\n\n      principales_paros = await executeQuery(sql_principales_paros, undefined, 'mapex');\n    }\n\n    // Obtener datos para gráfico de producción por turno\n    let produccion_turno = [];\n    if (id_his_of) {\n      const sql_produccion_turno = `\n        SELECT\n          cm.rt_desc_turno as turno,\n          CONVERT(VARCHAR(10), hp.fecha_fin, 111) as fecha,\n          SUM(hp.unidades_ok) as unidades_ok,\n          SUM(hp.unidades_nok) as unidades_nok,\n          SUM(hp.unidades_repro) as unidades_rw\n        FROM his_prod hp\n        INNER JOIN cfg_maquina cm ON hp.Id_maquina = cm.id_maquina\n        INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase\n        WHERE hf.id_his_of = '${id_his_of}'\n        AND cm.Cod_maquina = '${machineId}'\n        GROUP BY cm.rt_desc_turno, CONVERT(VARCHAR(10), hp.fecha_fin, 111)\n        ORDER BY fecha, turno\n      `;\n\n      produccion_turno = await executeQuery(sql_produccion_turno, undefined, 'mapex');\n    }\n\n    // Calcular métricas derivadas\n    const total_produced = produccion_data ?\n      (produccion_data.total_ok || 0) + (produccion_data.total_nok || 0) + (produccion_data.total_rw || 0) :\n      (row.Unidades_ok || 0) + (row.Rt_Unidades_nok || 0) + (row.Unidades_rw || 0);\n\n    const avance = row.Rt_Unidades_planning > 0 ?\n      Math.round((total_produced / row.Rt_Unidades_planning) * 10000) / 100 : 0;\n\n    const remaining_pieces = row.Rt_Unidades_planning - total_produced;\n    const remaining_time = calculateRemainingTime(remaining_pieces, row.f_velocidad || 0);\n\n    // Calcular desviación (calidad)\n    const desviacion = total_produced > 0 ?\n      Math.round(((row.Rt_Unidades_nok || 0) / total_produced) * 10000) / 100 : 0;\n\n    return {\n      // Información básica\n      ...row,\n      cod_of,\n      id_his_of,\n\n      // Métricas calculadas\n      total_produced,\n      avance_porcentaje: avance,\n      remaining_pieces,\n      remaining_time,\n      desviacion_porcentaje: desviacion,\n\n      // Datos OEE\n      oee_data,\n\n      // Datos de producción detallados\n      produccion_data,\n\n      // Datos de paros\n      paros_data,\n      principales_paros,\n\n      // Datos para gráficos\n      produccion_turno,\n\n      // Información adicional para UI\n      status: {\n        avance_class: avance >= 90 ? 'success' : (avance >= 70 ? 'warning' : 'danger'),\n        tiempo_class: remaining_pieces > 0 && row.f_velocidad > 0 ?\n          (remaining_pieces / row.f_velocidad > 24 ? 'warning' : 'success') : 'info',\n        desviacion_class: desviacion > 5 ? 'danger' : 'success'\n      }\n    };\n  } catch (error) {\n    console.error('❌ Erro ao obter dados OF:', error);\n    return null;\n  }\n}\n\nasync function getParosData(machineId: string) {\n  try {\n    // Obtener la OF actual de la máquina\n    const sql_of_actual = `SELECT Rt_Cod_of FROM cfg_maquina WHERE Cod_maquina = '${machineId}'`;\n    const result_of_actual = await executeQuery(sql_of_actual, undefined, 'mapex');\n    const of_actual = result_of_actual[0]?.Rt_Cod_of || '';\n\n    // Obtener tipos de paro para el filtro\n    const sql_tipos_paro = `SELECT DISTINCT id_paro, desc_paro FROM cfg_paro ORDER BY desc_paro`;\n    const tipos_paro = await executeQuery(sql_tipos_paro, undefined, 'mapex');\n\n    // Obtener lista de OFs para el filtro (últimos 7 días por defecto)\n    const sql_ofs = `\n      SELECT DISTINCT substring(hof.cod_of, 1, 15) as cod_of, hof.fecha_ini\n      FROM his_prod hp\n      INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase\n      INNER JOIN his_of hof ON hf.id_his_of = hof.id_his_of\n      INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n      WHERE cm.Cod_maquina = '${machineId}'\n      AND hof.fecha_ini >= DATEADD(day, -7, GETDATE())\n      ORDER BY hof.fecha_ini DESC\n    `;\n    const ofs = await executeQuery(sql_ofs, undefined, 'mapex');\n\n    // Obtener paros con filtros (últimos 30 días por defecto)\n    const sql_paros = `\n      SELECT\n        hpp.fecha_ini,\n        hpp.fecha_fin,\n        DATEDIFF(MINUTE, hpp.fecha_ini, hpp.fecha_fin) as duracion_minutos,\n        cp.id_paro,\n        cp.desc_paro,\n        substring(hof.cod_of, 1, 15) as cod_of,\n        hpp.Id_operario,\n        COALESCE(hpo.observaciones, '') as observaciones\n      FROM his_prod hp\n      INNER JOIN his_prod_paro hpp ON hp.id_his_prod = hpp.id_his_prod\n      INNER JOIN cfg_paro cp ON hpp.id_paro = cp.id_paro\n      INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n      INNER JOIN his_fase hf ON hp.id_his_fase = hf.id_his_fase\n      INNER JOIN his_of hof ON hf.id_his_of = hof.id_his_of\n      LEFT JOIN his_paro_obs hpo ON hpo.his_paro = hpp.his_paro\n      WHERE cm.Cod_maquina = '${machineId}'\n      AND hpp.fecha_ini >= DATEADD(day, -30, GETDATE())\n      ORDER BY hpp.fecha_ini DESC\n    `;\n\n    const paros = await executeQuery(sql_paros, undefined, 'mapex');\n\n    // Calcular estadísticas de paros\n    const total_paros = paros.length;\n    const total_minutos = paros.reduce((sum, p) => sum + (p.duracion_minutos || 0), 0);\n\n    // Agrupar paros por tipo\n    const paros_por_tipo: { [key: string]: { count: number; minutos: number } } = {};\n    paros.forEach(paro => {\n      const tipo = paro.desc_paro || 'Sin tipo';\n      if (!paros_por_tipo[tipo]) {\n        paros_por_tipo[tipo] = { count: 0, minutos: 0 };\n      }\n      paros_por_tipo[tipo].count++;\n      paros_por_tipo[tipo].minutos += paro.duracion_minutos || 0;\n    });\n\n    return {\n      paros,\n      estadisticas: {\n        total_paros,\n        total_minutos,\n        promedio_minutos: total_paros > 0 ? Math.round(total_minutos / total_paros) : 0\n      },\n      paros_por_tipo: Object.entries(paros_por_tipo).map(([tipo, data]) => ({\n        tipo,\n        count: data.count,\n        minutos: data.minutos,\n        porcentaje: total_paros > 0 ? Math.round((data.count / total_paros) * 100) : 0\n      })),\n      filtros: {\n        of_actual,\n        tipos_paro,\n        ofs,\n        fecha_desde: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],\n        fecha_hasta: new Date().toISOString().split('T')[0]\n      }\n    };\n  } catch (error) {\n    console.error('❌ Erro ao obter dados de paros:', error);\n    return {\n      paros: [],\n      estadisticas: { total_paros: 0, total_minutos: 0, promedio_minutos: 0 },\n      paros_por_tipo: [],\n      filtros: { of_actual: '', tipos_paro: [], ofs: [], fecha_desde: '', fecha_hasta: '' }\n    };\n  }\n}\n\nasync function getProduccionData(machineId: string) {\n  const sql = `\n    SELECT TOP 20\n      hp.fecha, hp.turno, hp.unidades_ok, hp.unidades_nok, hp.unidades_rw,\n      hp.tiempo_produccion, hp.velocidad_media, hp.nom_operario\n    FROM his_prod hp\n    INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n    WHERE cm.Cod_maquina = '${machineId}'\n      AND hp.fecha >= DATEADD(day, -30, GETDATE())\n    ORDER BY hp.fecha DESC, hp.turno DESC\n  `;\n\n  try {\n    return await executeQuery(sql, undefined, 'mapex');\n  } catch (error) {\n    console.warn('⚠️ Error al obtener datos - retornando datos vacíos');\n    return [];\n  }\n}\n\nasync function getOEEData(machineId: string) {\n  const sql = `\n    SELECT TOP 10\n      fecha, turno,\n      disponibilidad, rendimiento, calidad, oee,\n      tiempo_planificado, tiempo_operativo, piezas_objetivo\n    FROM F_his_ct\n    WHERE id_maquina = (SELECT id_maquina FROM cfg_maquina WHERE Cod_maquina = '${machineId}')\n      AND fecha >= DATEADD(day, -30, GETDATE())\n    ORDER BY fecha DESC, turno DESC\n  `;\n\n  try {\n    return await executeQuery(sql, undefined, 'mapex');\n  } catch (error) {\n    console.warn('⚠️ Error al obtener datos - retornando datos vacíos');\n    return [];\n  }\n}\n\nasync function getPedidosData(machineId: string) {\n  try {\n    const sql = `\n      SELECT TOP 20\n        p.cod_pedido, p.desc_producto, p.cantidad_pedido, p.cantidad_entregada,\n        p.fecha_pedido, p.fecha_entrega_prevista, p.estado_pedido\n      FROM pedidos p\n      INNER JOIN cfg_maquina cm ON p.id_maquina = cm.id_maquina\n      WHERE cm.Cod_maquina = '${machineId}'\n        AND p.fecha_pedido >= DATEADD(day, -60, GETDATE())\n      ORDER BY p.fecha_pedido DESC\n    `;\n\n    return await executeQuery(sql, undefined, 'sage');\n  } catch (error) {\n    console.warn('⚠️ Banco SAGE não disponível para pedidos - retornando dados vazios');\n    return [];\n  }\n}\n\nasync function getHistoricoData(machineId: string) {\n  const sql = `\n    SELECT\n      CAST(hp.fecha AS DATE) as fecha,\n      SUM(hp.unidades_ok) as total_ok,\n      SUM(hp.unidades_nok) as total_nok,\n      SUM(hp.unidades_rw) as total_rw,\n      AVG(CASE WHEN hp.unidades_ok + hp.unidades_nok + hp.unidades_rw > 0\n               THEN (hp.unidades_ok * 100.0) / (hp.unidades_ok + hp.unidades_nok + hp.unidades_rw)\n               ELSE 0 END) as eficiencia_diaria\n    FROM his_prod hp\n    INNER JOIN cfg_maquina cm ON hp.id_maquina = cm.id_maquina\n    WHERE cm.Cod_maquina = '${machineId}'\n      AND hp.fecha >= DATEADD(day, -90, GETDATE())\n    GROUP BY CAST(hp.fecha AS DATE)\n    ORDER BY fecha DESC\n  `;\n\n  try {\n    return await executeQuery(sql, undefined, 'mapex');\n  } catch (error) {\n    console.warn('⚠️ Error al obtener datos - retornando datos vacíos');\n    return [];\n  }\n}\n\nasync function getVentasData(machineId: string) {\n  try {\n    const sql = `\n      SELECT TOP 20\n        v.cod_venta, v.cliente, v.producto, v.cantidad, v.valor_venta,\n        v.fecha_venta, v.estado_entrega\n      FROM ventas v\n      INNER JOIN cfg_maquina cm ON v.id_maquina = cm.id_maquina\n      WHERE cm.Cod_maquina = '${machineId}'\n        AND v.fecha_venta >= DATEADD(day, -90, GETDATE())\n      ORDER BY v.fecha_venta DESC\n    `;\n\n    return await executeQuery(sql, undefined, 'sage');\n  } catch (error) {\n    console.warn('⚠️ Banco SAGE não disponível para vendas - retornando dados vazios');\n    return [];\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}